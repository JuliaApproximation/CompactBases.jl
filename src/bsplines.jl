"""
    BSpline(t, x, w, B, S)

Basis structure for the B-splines generated by the knot set `t`. `x`
and `w` are the associated quadrature roots and weights, respectively,
the columns of `B` correspond to the B-splines resolved on the
quadrature roots, and `S` is the (banded) B-spline overlap matrix.
"""
struct BSpline{T,R<:Real,
               KnotSet<:AbstractKnotSet{<:Any,<:Any,<:Any,R},
               XV<:AbstractVector{T},
               WV<:AbstractVector{R},
               BM<:AbstractMatrix{T},
               SM<:AbstractMatrix{T}} <: Basis{T}
    t::KnotSet
    x::XV
    w::WV
    B::BM
    S::SM
end

function basis_functions(t::AbstractKnotSet{k}, x::AbstractVector{T}, m=0) where {k,T}
    nf = numfunctions(t)
    B = spzeros(T, length(x), nf)

    nei = nonempty_intervals(t)
    # This is the amount of quadrature points per interval (assuming
    # the same amount per interval, which is currently the case), this
    # could conceivably be passed as an argument, instead.
    N = findlast(e -> e < t[nei[1]+1], x)

    ix = 1
    for i ∈ nei
        # These are the functions which are non-zero on the interval
        # t[i]..t[i+1].
        for j ∈ max(1,i-k+1):min(i,nf)
            eⱼ = UnitVector{T}(nf, j)
            for l ∈ ix:ix+N-1
                B[l,j] = deBoor(t, eⱼ, x[l], i, m)
            end
        end
        ix += N
    end

    B
end

basis_functions(B::BSpline, args...) = basis_functions(B.t, B.x, args...)

function basis_functions(B::RestrictedQuasiArray{<:Any,<:Any,<:BSpline}, args...)
    B′,restriction = B.args
    a,b = restriction_extents(restriction)
    basis_functions(B′, args...)[:,1+a:end-b]
end

function overlap_matrix!(S::BandedMatrix, χ, ξ, w)
    m = min(size(S,1),size(χ,2))
    n = min(size(S,2),size(ξ,2))
    # It is assumed that the bandwidth is correct for the overlap
    # ⟨χ|ξ⟩.
    p = bandwidth(S, 1)
    W = Diagonal(w)
    for i ∈ 1:m
        for j ∈ max(i-p,1):min(i+p,n)
            S[i,j] = χ[:,i]' * W * ξ[:,j]
        end
    end
    χ == ξ && isreal(χ) && isreal(W) && isreal(ξ) ?
        Symmetric(S) : S
end

function BSpline(t::AbstractKnotSet{k}, x::AbstractVector{T}, w::AbstractVector) where {k,T}
    B = basis_functions(t, x)

    nf = numfunctions(t)
    S = BandedMatrix(Zeros{T}(nf, nf), (k-1,k-1))

    BSpline(t, x, w, B, overlap_matrix!(S, B, B, w))
end

"""
    BSpline(t[, N])

Create the B-spline basis corresponding to the knot set `t`. `N` is
the amount of Gauß–Legendre quadrature points per interval.
"""
BSpline(t::AbstractKnotSet, N) = BSpline(t, lgwt(t, N)...)

"""
    BSpline(t[; k′=3])
Create the B-spline basis corresponding to the knot set `t`. `k′` is
the highest polynomial order of operators for which it should be
possible to compute the matrix elements exactly (via Gauß–Legendre
quadrature). The default `k′=3` corresponds to operators O(x²).
"""
BSpline(t::AbstractKnotSet; k′=3) = BSpline(t, num_quadrature_points(order(t), k′))

const RestrictedBSpline{T} = Union{RestrictedBasis{<:BSpline{T}},<:RestrictedQuasiArray{<:Any,<:Any,<:BSpline{T}}}
const AdjointRestrictedBSpline{T} = Union{AdjointRestrictedBasis{<:BSpline{T}},<:AdjointRestrictedQuasiArray{<:Any,<:Any,<:BSpline{T}}}

const BSplineOrRestricted{T} = BasisOrRestricted{<:BSpline{T}}
const AdjointBSplineOrRestricted{T} = AdjointBasisOrRestricted{<:BSpline{T}}

# * Properties

axes(B::BSpline) = (Inclusion(first(B.t)..last(B.t)), Base.OneTo(numfunctions(B.t)))
size(B::BSpline) = (ℵ₁, numfunctions(B.t))
size(B::RestrictedQuasiArray{<:Any,2,<:BSpline}) = (ℵ₁, length(B.args[2].data))
==(A::BSpline,B::BSpline) = A.t == B.t
==(A::BSplineOrRestricted,B::BSplineOrRestricted) = unrestricted_basis(A) == unrestricted_basis(B)

order(B::BSplineOrRestricted) = order(unrestricted_basis(B).t)

function show(io::IO, B::BSpline{T}) where T
    write(io, "BSpline{$(T)} basis with $(B.t)")
end

function show(io::IO, B::RestrictedQuasiArray{T,2,BSpline{T}}) where T
    B′,restriction = B.args
    a,b = restriction_extents(restriction)
    N = numfunctions(B′.t)
    show(io, B′)
    write(io, ", restricted to basis functions $(1+a)..$(N-b) $(a>0 || b>0 ? "⊂" : "⊆") 1..$(N)")
end

restriction_extents(B::BSpline) = 0,0
restriction_extents(B::RestrictedQuasiArray{<:Any,2,<:BSpline}) =
    restriction_extents(B.args[2])

locs(B::BSpline) = B.x

locs(B::RestrictedQuasiArray{<:Any,2,<:BSpline}) =
    first(B.args).x

weights(B::BSpline) = B.w

weights(B::RestrictedQuasiArray{<:Any,2,<:BSpline}) =
    first(B.args).w

IntervalSets.leftendpoint(B::BSpline) = B.x[1]
IntervalSets.rightendpoint(B::BSpline) = B.x[end]

IntervalSets.leftendpoint(B::RestrictedQuasiArray{<:Any,2,<:BSpline}) =
    leftendpoint(B.args[1])
IntervalSets.rightendpoint(B::RestrictedQuasiArray{<:Any,2,<:BSpline}) =
    rightendpoint(B.args[1])

# # * Basis functions

"""
    deBoor(t, c, x[, i[, m=0]])

Evaluate the spline given by the knot set `t` and the set of control
points `c` at `x` using de Boor's algorithm. `i` is the index of the
knot interval containing `x`. If `m≠0`, calculate the `m`th derivative
at `x` instead.
"""
function deBoor(t::AbstractKnotSet, c::AbstractVector{T}, x,
                i=find_interval(t, x), m=0) where T
    isnothing(i) && return zero(eltype(t))
    k = order(t)
    nc = length(c)
    k == 1 && return (nc < i || m > 0) ? zero(T) : c[i]

    α = [r > 0 && r ≤ nc ? c[r] : zero(T)
         for r ∈ i-k+1:i]
    nt = length(t)
    nf = numfunctions(t)
    for j = 1:k-1
        for r = i:-1:max(i-k+j,1)
            jjj = r+k-j
            (jjj > nt || jjj < 1) && continue
            r′ = r - i + k
            r ≠ 1 && r′ == 1 && continue

            a = t[r+k-j]
            b = t[r]

            α[r′] = if j ≤ m
                (k-j)*if r == 1
                    -α[r′]
                elseif r == nf + j
                    α[r′-1]
                else
                    α[r′-1] - α[r′]
                end
            else
                if r == 1
                    (b-x)*α[r′]
                elseif r == nf + j
                    (x-a)*α[r′-1]
                else
                    ((x-a)*α[r′-1] + (b-x)*α[r′])
                end
            end
            α[r′] /= (b-a)
        end
    end

    α[end]
end

getindex(B::BSpline{T}, x::Real, j::Integer) where T =
    deBoor(B.t, UnitVector{T}(size(B,2), j),
           x, find_interval(B.t, x))

function basis_function!(χ, B::BSpline{T}, x::AbstractRange, j) where T
    eⱼ = UnitVector{T}(size(B,2), j)
    for (is,k) ∈ within_support(x, B.t, j)
        for i in is
            χ[i] = deBoor(B.t, eⱼ, x[i], k)
        end
    end
end

function getindex(B::BSpline{T}, x::AbstractRange, sel::AbstractVector) where T
    χ = spzeros(T, length(x), length(sel))
    for j in sel
        basis_function!(view(χ, :, j), B, x, j)
    end
    χ
end

function getindex(B::BSpline{T}, x::AbstractRange, j::Integer) where T
    χ = spzeros(T, length(x))
    basis_function!(χ, B, x, j)
    χ
end

getindex(B::BSplineOrRestricted, x, ::Colon) =
    getindex(B, x, axes(B,2))

# * Types

const SplineArray{T,N,B<:BSplineOrRestricted} = MulQuasiArray{T,N,<:Mul{<:Any,<:Tuple{B,<:AbstractArray{T,N}}}}
const SplineVector{T,B<:BSplineOrRestricted} = SplineArray{T,1,B}
const SplineMatrix{T,B<:BSplineOrRestricted} = SplineArray{T,2,B}
const SplineVecOrMat{T,B<:BSplineOrRestricted} = Union{SplineVector{T,B},SplineMatrix{T,B}}

Base.show(io::IO, spline::SplineVector) =
    write(io, "Spline on $(spline.args[1])")

Base.show(io::IO, spline::SplineMatrix) =
    write(io, "$(size(spline, 2))d spline on $(spline.args[1])")

# * Mass matrix
@simplify function *(Ac::QuasiAdjoint{<:Any,<:BSpline}, B::BSpline)
    A = parent(Ac)
    A.t.t == B.t.t || throw(ArgumentError("Cannot multiply B-spline bases with different knot sets"))
    A.x == B.x && A.w == B.w || throw(ArgumentError("Cannot multiply B-spline bases resolved on different Gauß–Legendre points"))

    A == B && return A.S

    k = max(order(A.t),order(B.t))
    m,n = size(A,2),size(B,2)

    S = BandedMatrix(Zeros{eltype(B)}(m,n), (k-1,k-1))
    overlap_matrix!(S, A.B, B.B, weights(A))
end

# * Function interpolation

function Base.:(\ )(B::BSpline, f::BroadcastQuasiArray)
    axes(f,1) == axes(B,1) ||
        throw(DimensionMismatch("Function on $(axes(f,1).domain) cannot be interpolated over basis on $(axes(B,1).domain)"))
    B.B \ getindex.(Ref(f), B.x)
end

function Base.:(\ )(B::RestrictedBSpline, f::BroadcastQuasiArray)
    axes(f,1) == axes(B,1) ||
        throw(DimensionMismatch("Function on $(axes(f,1).domain) cannot be interpolated over basis on $(axes(B,1).domain)"))
    x = locs(B)
    V = B[x,:]
    V \ getindex.(Ref(f), x)
end

export BSpline
