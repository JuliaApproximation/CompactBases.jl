<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function approximation · CompactBases.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../assets/latex.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="CompactBases.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">CompactBases.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../inner_products/">Inner products &amp; norms</a></li><li><span class="tocitem">Operators</span><ul><li><a class="tocitem" href="../../diagonal_operators/">Diagonal operators</a></li></ul></li><li><a class="tocitem" href="../../densities/">Densities</a></li><li><span class="tocitem">Finite-differences</span><ul><li><a class="tocitem" href="../../fd_overview/">Overview</a></li><li><a class="tocitem" href="../../fd_non_uniform/">Non-uniform grids</a></li></ul></li><li><span class="tocitem">B-splines</span><ul><li><a class="tocitem" href="../theory/">Theory</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox" checked/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Usage</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../usage/">Basis creation</a></li><li><a class="tocitem" href="../knot_sets/">Knot sets</a></li><li><input class="collapse-toggle" id="menuitem-7-2-3" type="checkbox" checked/><label class="tocitem" for="menuitem-7-2-3"><span class="docs-label">Splines</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../splines/">Spline creation &amp; evaluation</a></li><li class="is-active"><a class="tocitem" href>Function approximation</a><ul class="internal"><li><a class="tocitem" href="#Smooth-interpolation-of-measurement-data-1"><span>Smooth interpolation of measurement data</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../operators/">Approximating operators</a></li><li><input class="collapse-toggle" id="menuitem-7-2-5" type="checkbox"/><label class="tocitem" for="menuitem-7-2-5"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../differentiation/">Differentiating functions</a></li><li><a class="tocitem" href="../odes/">Ordinary differential equations</a></li><li><a class="tocitem" href="../eigenproblems/">Eigenproblems</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">B-splines</a></li><li><a class="is-disabled">Usage</a></li><li><a class="is-disabled">Splines</a></li><li class="is-active"><a href>Function approximation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function approximation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaApproximation/CompactBases.jl/blob/master/docs/src/bsplines/function_approximation.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-approximation-1"><a class="docs-heading-anchor" href="#Function-approximation-1">Function approximation</a><a class="docs-heading-anchor-permalink" href="#Function-approximation-1" title="Permalink"></a></h1><p>To approximate a mathematical function on a B-spline basis, we can simply <em>solve</em> for the coefficients:</p><pre><code class="language-julia">julia&gt; t = LinearKnotSet(7, 0, 7, 10);

julia&gt; B = BSpline(t)
BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..7.0 (10 intervals)

julia&gt; c = B \ sin
16-element Array{Float64,1}:
  3.674947319163227e-7
  0.1166649763895669
  0.3500043164970867
  0.6828451145424481
  1.0237038168861594
  1.1358262863822566
  0.7361804983706153
 -0.009705277902046651
 -0.7510239693627963
 -1.139127153806961
 -0.991477377385712
 -0.4798514317407342
  0.024153163433647172
  0.3716550472969573
  0.5690327347258564
  0.6569863188695337</code></pre><p>The top panel shows the expansion coefficents and the reconstructed function, the middle panel the reconstruction error, and the bottom panel the underlying basis functions.</p><p><img src="../../figures/bsplines/function-interpolation.svg" alt="Function interpolation by B-splines"/></p><p>Since the sine function is non-zero at <span>$x=7$</span>, it is important that our basis set includes a B-spline that supports this, hence the full multiplicity of last knot. The sine function <em>is</em> zero at the first knot, however, something that is reflected in the fact that the first expansion coefficient is almost zero. In problems where vanishing boundary conditions are stipulated, this can be enforced by dropping the first/last spline:</p><pre><code class="language-julia">julia&gt; t = LinearKnotSet(7, 0.0, 1.0, 6);

julia&gt; B = BSpline(t)
BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (6 intervals)

julia&gt; B̃ = B[:,2:end-1]
BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (6 intervals), restricted to basis functions 2..11 ⊂ 1..12</code></pre><p>We can now compare how well the restricted basis can reconstruct different functions, compared to the unrestricted one:</p><pre><code class="language-julia">julia&gt; f1 = x -&gt; sin(2π*x)
#121 (generic function with 1 method)

julia&gt; f2 = x -&gt; cos(2π*x)
#123 (generic function with 1 method)

julia&gt; c1 = B \ f1
12-element Array{Float64,1}:
  8.595306123332097e-6
  0.17449541085301523
  0.5236843390613484
  0.9897088684171409
  1.265948043821677
  0.6905122508504199
 -0.6905122508504197
 -1.2659480438216766
 -0.9897088684171416
 -0.5236843390613481
 -0.1744954108530153
 -8.59530612374404e-6

julia&gt; c2 = B \ f2
12-element Array{Float64,1}:
  0.9999984763007934
  1.000010902252537
  0.9268416666707764
  0.5980612634315096
 -0.1993704588377225
 -1.1959917207779527
 -1.195991720777952
 -0.1993704588377244
  0.5980612634315112
  0.9268416666707747
  1.000010902252537
  0.9999984763007937

julia&gt; c̃1 = B̃ \ f1
10-element Array{Float64,1}:
  0.17450648562854001
  0.5236722006849034
  0.9897209715549453
  1.2659362792307434
  0.6905240028400118
 -0.690524002840012
 -1.265936279230742
 -0.989720971554948
 -0.5236722006849018
 -0.1745064856285418

julia&gt; c̃2 = B̃ \ f2
10-element Array{Float64,1}:
  2.1869627421644986
 -0.18872692489766923
  1.4520927974960849
 -0.6709944899983972
 -1.057228429296141
 -1.057228429296146
 -0.6709944899983946
  1.4520927974960847
 -0.1887269248976696
  2.1869627421644977</code></pre><p><img src="../../figures/bsplines/restricted-basis-interpolation.svg" alt="Reconstruction of function interpolated on restricted bases"/></p><p>As is to be expected, the sine function is perfectly reconstructed in both cases, whilst the cosine fails spectactularly in the restricted case.</p><h2 id="Smooth-interpolation-of-measurement-data-1"><a class="docs-heading-anchor" href="#Smooth-interpolation-of-measurement-data-1">Smooth interpolation of measurement data</a><a class="docs-heading-anchor-permalink" href="#Smooth-interpolation-of-measurement-data-1" title="Permalink"></a></h2><p>If instead of a mathematical function, we have a dataset that we wish to interpolate smoothly, we accomplish that quite simply by evaluating the B-splines on the values of <span>$x$</span> where we know the data. We must beware of overfitting though, which is illustrated below. First, we generate some “measurement” data:</p><pre><code class="language-julia">julia&gt; f = x -&gt; sin(2π*x)
#9 (generic function with 1 method)

julia&gt; rng = MersenneTwister(123);

julia&gt; N = 10
10

julia&gt; x = clamp.(sort(range(0, stop=1, length=N) + 0.1(2rand(rng,N) .- 1)), 0, 1);

julia&gt; y = f.(x) + 0.1(2rand(rng,N) .- 1);</code></pre><p>We then construct two B-splines sets of different orders, but on the same domain:</p><pre><code class="language-julia">julia&gt; t3 = LinearKnotSet(3, 0.0, 1.0, 6);

julia&gt; t4 = LinearKnotSet(4, 0.0, 1.0, 6);

julia&gt; B3 = BSpline(t3,k′=1)
BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 3 (parabolic) on 0.0..1.0 (6 intervals)

julia&gt; B4 = BSpline(t4,k′=1)
BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (6 intervals)

julia&gt; c3 = B3[x,:] \ y
8-element Array{Float64,1}:
  0.09059408654085727
  0.3193964537812517
  1.2724504917348318
  0.48266890171285365
 -0.5585179917405891
 -1.2049827692771158
 -0.5094743222571649
 -0.27749270716604346

julia&gt; c4 = B4[x,:] \ y
9-element Array{Float64,1}:
  2.32388044050468
 -1.1504112365148684
  1.4118937176980075
  0.9380508194440034
  0.005584178064480077
 -1.060186123070226
 -1.1044261039469099
 -0.1538696429680995
 -1.00556852643735</code></pre><p><img src="../../figures/bsplines/smooth-interpolation.svg" alt="Smooth interpolation"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../splines/">« Spline creation &amp; evaluation</a><a class="docs-footer-nextpage" href="../operators/">Approximating operators »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 26 March 2021 08:22">Friday 26 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
