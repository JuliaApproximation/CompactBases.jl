var documenterSearchIndex = {"docs":
[{"location":"bsplines/function_approximation/#Function-approximation-1","page":"Function approximation","title":"Function approximation","text":"","category":"section"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"To approximate a mathematical function on a B-spline basis, we can simply solve for the coefficients:","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"julia> t = LinearKnotSet(7, 0, 7, 10);\n\njulia> B = BSpline(t)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..7.0 (10 intervals)\n\njulia> c = B \\ sin\n16-element Array{Float64,1}:\n  3.674947319163227e-7\n  0.1166649763895669\n  0.3500043164970867\n  0.6828451145424481\n  1.0237038168861594\n  1.1358262863822566\n  0.7361804983706153\n -0.009705277902046651\n -0.7510239693627963\n -1.139127153806961\n -0.991477377385712\n -0.4798514317407342\n  0.024153163433647172\n  0.3716550472969573\n  0.5690327347258564\n  0.6569863188695337","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"The top panel shows the expansion coefficents and the reconstructed function, the middle panel the reconstruction error, and the bottom panel the underlying basis functions.","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"(Image: Function interpolation by B-splines)","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"Since the sine function is non-zero at x=7, it is important that our basis set includes a B-spline that supports this, hence the full multiplicity of last knot. The sine function is zero at the first knot, however, something that is reflected in the fact that the first expansion coefficient is almost zero. In problems where vanishing boundary conditions are stipulated, this can be enforced by dropping the first/last spline:","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"julia> t = LinearKnotSet(7, 0.0, 1.0, 6);\n\njulia> B = BSpline(t)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (6 intervals)\n\njulia> B̃ = B[:,2:end-1]\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (6 intervals), restricted to basis functions 2..11 ⊂ 1..12","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"We can now compare how well the restricted basis can reconstruct different functions, compared to the unrestricted one:","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"julia> f1 = x -> sin(2π*x)\n#121 (generic function with 1 method)\n\njulia> f2 = x -> cos(2π*x)\n#123 (generic function with 1 method)\n\njulia> c1 = B \\ f1\n12-element Array{Float64,1}:\n  8.595306123332097e-6\n  0.17449541085301523\n  0.5236843390613484\n  0.9897088684171409\n  1.265948043821677\n  0.6905122508504199\n -0.6905122508504197\n -1.2659480438216766\n -0.9897088684171416\n -0.5236843390613481\n -0.1744954108530153\n -8.59530612374404e-6\n\njulia> c2 = B \\ f2\n12-element Array{Float64,1}:\n  0.9999984763007934\n  1.000010902252537\n  0.9268416666707764\n  0.5980612634315096\n -0.1993704588377225\n -1.1959917207779527\n -1.195991720777952\n -0.1993704588377244\n  0.5980612634315112\n  0.9268416666707747\n  1.000010902252537\n  0.9999984763007937\n\njulia> c̃1 = B̃ \\ f1\n10-element Array{Float64,1}:\n  0.17450648562854001\n  0.5236722006849034\n  0.9897209715549453\n  1.2659362792307434\n  0.6905240028400118\n -0.690524002840012\n -1.265936279230742\n -0.989720971554948\n -0.5236722006849018\n -0.1745064856285418\n\njulia> c̃2 = B̃ \\ f2\n10-element Array{Float64,1}:\n  2.1869627421644986\n -0.18872692489766923\n  1.4520927974960849\n -0.6709944899983972\n -1.057228429296141\n -1.057228429296146\n -0.6709944899983946\n  1.4520927974960847\n -0.1887269248976696\n  2.1869627421644977","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"(Image: Reconstruction of function interpolated on restricted bases)","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"As is to be expected, the sine function is perfectly reconstructed in both cases, whilst the cosine fails spectactularly in the restricted case.","category":"page"},{"location":"bsplines/function_approximation/#Smooth-interpolation-of-measurement-data-1","page":"Function approximation","title":"Smooth interpolation of measurement data","text":"","category":"section"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"If instead of a mathematical function, we have a dataset that we wish to interpolate smoothly, we accomplish that quite simply by evaluating the B-splines on the values of x where we know the data. We must beware of overfitting though, which is illustrated below. First, we generate some “measurement” data:","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"julia> f = x -> sin(2π*x)\n#9 (generic function with 1 method)\n\njulia> rng = MersenneTwister(123);\n\njulia> N = 10\n10\n\njulia> x = clamp.(sort(range(0, stop=1, length=N) + 0.1(2rand(rng,N) .- 1)), 0, 1);\n\njulia> y = f.(x) + 0.1(2rand(rng,N) .- 1);","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"We then construct two B-splines sets of different orders, but on the same domain:","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"julia> t3 = LinearKnotSet(3, 0.0, 1.0, 6);\n\njulia> t4 = LinearKnotSet(4, 0.0, 1.0, 6);\n\njulia> B3 = BSpline(t3,k′=1)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 3 (parabolic) on 0.0..1.0 (6 intervals)\n\njulia> B4 = BSpline(t4,k′=1)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (6 intervals)\n\njulia> c3 = B3[x,:] \\ y\n8-element Array{Float64,1}:\n  0.09059408654085727\n  0.3193964537812517\n  1.2724504917348318\n  0.48266890171285365\n -0.5585179917405891\n -1.2049827692771158\n -0.5094743222571649\n -0.27749270716604346\n\njulia> c4 = B4[x,:] \\ y\n9-element Array{Float64,1}:\n  2.32388044050468\n -1.1504112365148684\n  1.4118937176980075\n  0.9380508194440034\n  0.005584178064480077\n -1.060186123070226\n -1.1044261039469099\n -0.1538696429680995\n -1.00556852643735","category":"page"},{"location":"bsplines/function_approximation/#","page":"Function approximation","title":"Function approximation","text":"(Image: Smooth interpolation)","category":"page"},{"location":"bsplines/theory/#Theory-1","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"The underlying equations for the definition and efficient evaluation of B-splines are introduced. Equations labelled (dB.A.ij) refer to equation (ij) in chapter A of","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Carl de Boor (2001). A Practical Guide to Splines. New York: Springer. ISBN: 978-0-387-95366-3.","category":"page"},{"location":"bsplines/theory/#Definitions-1","page":"Theory","title":"Definitions","text":"","category":"section"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"The order of the polynomial is designated k, equal to the degree + 1, i.e. a parabolic polynomial is of order 3.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"The B-splines can be defined through the Cox–de Boor recursion relation: beginequation tagdBIX14 Bjk defd omega_jkBjk-1 + (1-omega_j+1k)Bj+1k-1 endequation where beginequation tagdBIX15 omega_jk(x) defd fracx-t_jt_j+k-1-t_j endequation and beginequation tagdBIX11 Br1(x) = begincases 1  xin t_rt_r+1)\n0  textrmelse\nendcasesquad rin1n_t-1 endequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Given a knot vector vect of length n_t, there are n_tkdefd n_t-k functions of order k. This implies that there is a highest order k a given knot set vector can support, i.e. k_textrmmax = n_t - 1.","category":"page"},{"location":"bsplines/theory/#Knot-sets-1","page":"Theory","title":"Knot sets","text":"","category":"section"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"As seen above, the B-splines are completely defined by the knot set vector vect.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"The knot set vect=bmat123456 gives rise to the following cardinal splines, of orders k=15: (Image: Cardinal splines)","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"By increasing the multiplicity of some knots, the continuity of the splines can be controlled. E.g. the knot set vect=bmat01134666, will yield the following splines: (Image: Discontinuous splines)","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Lastly, it is very common to pad the knot set such that the first and last knot have multiplicity k; this simplifies the implementation of boundary conditions when B-splines are used for solving differential equations: (Image: Full multiplicity splines)","category":"page"},{"location":"bsplines/theory/#de-Boor's-algorithm-1","page":"Theory","title":"de Boor's algorithm","text":"","category":"section"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"An efficient way of evaluating the B-splines is given by de Boor's algorithm. The algorithm described in the Wikipedia article [1] assumes full multiplicity at the endpoints of the knot set, i.e. that the first and last points are repeated k times. In the description of the same algorithm, de Boor additionally assumes a strictly increasing knot set, i.e. t_i+1t_i, do avoid any divisions by zero. Since one of the goals for this package is maximum flexibility in choosing the knot set, a derivation of an only slightly more general version of de Boor's algorithm follows.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Given a knot set vect of length n_t, the spline f(x) is given by beginequation tagdBX23⅓  ⅔ beginaligned f(x) = sum_r=1^n_t-k alpha_r Brk(x)\n= sum_r=1^n_t-k alpha_rfracx-t_rt_r+k-1-t_rBrk-1(x)+ sum_r=1^n_t-k alpha_rfract_r+k-xt_r+k-t_r+1Br+1k-1(x)\n= sum_r=1^n_t-k alpha_rfracx-t_rt_r+k-1-t_rBrk-1(x)+ sum_r=2^n_t-k+1 alpha_r-1fract_r+k-1-xt_r+k-1-t_rBrk-1(x)\n= fracx-t_1t_k-t_1alpha_1B1k-1(x) + left sum_r=2^n_t-k frac(x-t_r)alpha_r+(t_r+k-1-x)alpha_r-1t_r+k-1-t_rBrk-1(x) right + fract_n_t-xt_n_t-t_n_t-k+1alpha_n_t-kBn_t-k+1k-1(x)\n= sum_i=1^n_t-k+1 alpha_i^2(x) Bik-1(x) endaligned endequation where beginequation tagdBX24 alpha_r^2(x) defd begincases displaystyle fracx-t_1t_k-t_1alpha_1  r=12ex displaystyle frac(x-t_r)alpha_r+(t_r+k-1-x)alpha_r-1t_r+k-1-t_r  rin2n_t-k2ex displaystyle fract_n_t-xt_n_t-t_n_t-k+1alpha_n_t-k  r = n_t - k + 1 endcases endequation We have thus reexpressed the spline function f(x) of order k as a linear combination of B-splines of order k-1. We can generalize this, to reexpress f(x) as a linear combination of B-splines of order k-j, with expansion coefficients beginequation labeleqndBX26 tagdBX26 alpha_r^j+1(x) defd begincases displaystyle fracx-t_1t_1+k-j-t_1alpha_1^j(x)  r=12ex displaystyle frac(x-t_r)alpha_r^j(x)+(t_r+k-j-x)alpha_r-1^j(x)t_r+k-j-t_r  rin2n_t-k+j-12ex displaystyle fract_n_t-xt_n_t-t_n_t-k+jalpha_n_t-k+j-1^j(x)  r = n_t - k + j endcases endequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"The difference between this derivation and those in the Wikipedia article and de Boor (2001), is that we here explicitly consider the limits of the sum imposed by the length of the knot set and the order k; this introduces the special cases for r=1n_t-k+j.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"An important philosophical difference between the Cox–de Boor recursion relation and de Boor's algorithm, is that whereas the former is a linear combination of basis functions evaluated at certain position x, the latter is linear combination of intervals (since the first-order functions Bj1 are non-zero within one interval only, and they are mutual orthogonal), with polynomial expansion coefficients alpha_i^k(x). To evaluate the spline function f(x), we first find the interval i which contains x. Even if the knot set is only non-decreasing, i.e. not strictly increasing, the interval containing x is uniquely defined, since there is only one for which t_i leq x  t_i+1; if the knot t_i has a multiplicity higher than unity, the additional intervals cannot contain x, since they are empty: t_i-1leq x  t_i = varnothing if t_i-1 = t_i. By finding the last i, for which t_i leq x, we thus guarantee that no divisions by zero will occur.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"[1]: NB that the Wikipedia article uses 0-based indexing, whereas de Boor and CompactBases.jl use 1-based indexing.","category":"page"},{"location":"bsplines/theory/#Integrals-1","page":"Theory","title":"Integrals","text":"","category":"section"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Since the B-splines are piecewise polynomials, they can be exactly integrated using Gauß–Legendre quadrature; an N-point quadrature can integrate a polynomial of degree 2N-1 exactly. We are usually interested in integrals on the form","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nmatrixelBj_1koperatorABj_2kequiv\nintdiffx\nconjBj_1k(x)\noperatorA\nBj_2k(x)\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"where operatorA is some operator. Assuming that operatorA can be approximated by a polynomial of order k, we need an N-point quadrature, such that 2N-1geq 2(k-1)+(k-1), e.g. for operatorAsim x^2, we choose N=ceilfrac2k+12=k+1.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"For every non-empty interval generated by the knot set, we setup a Gauß–Legendre quadrature, such that an integral is approximated as","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nintlimits_a^b diffxf(x)approx\nfracb-a2sum_i=1^n w_i\nfleft(fracb-a2x_i+fraca+b2right)\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"within each interval.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"If we again consider the knot set vect=bmat01134666 and allow operators of maximal polynomial order k=3, we get the following distribution quadrature points:","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"(Image: Quadrature points)","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Note that no quadrature points were generated for the intervals t_it_i+1), i=267, since those intervals are empty. Also note that the quadrature points are interior, i.e. the domain boundaries are not included. That can be useful for dealing with functions which are singular/undefined at the boundaries.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"With the quadrature in place, it becomes very easy to compute the overlap matrix:","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nmatS_ijk defd braketBikBjk\napprox sum_l w_l conjBik(x_l) Bjk(x_l)\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"For the knot set above, we find","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"matS =\nbmat06        0222222    00444444   00         00\n 0222222   0466667    0307407    00037037   00\n 00444444   0307407    0962963    0307407    00444444\n 00        00037037   0307407    0466667    0222222\n 00        00         00444444   0222222    04","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"from which we see that the individual B-splines Bik are non-zero only on the interval t_it_i+k), except for the last B-spline that is non-zero also at the end of the interval, t_it_i+k.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"If we want to employ two B-spline sets of different orders, we must make sure they share the same knot set and quadrature points (and that the latter support the combined polynomial order).","category":"page"},{"location":"bsplines/theory/#Derivatives-1","page":"Theory","title":"Derivatives","text":"","category":"section"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"A property of B-splines is that the first derivative of a spline is given by","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\ntagdBX12\npartial\nsum_j alpha_jBjk =\n(k-1)sum_j\nfracalpha_j - alpha_j-1t_j+k-1-t_jBjk-1\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"and by extension","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\ntagdBX15\npartial^m\nsum_j alpha_jBjk =\nsum_j alpha_j^(m+1)Bjj-m\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"where","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nlabeleqndBX16\ntagdBX16\nalpha_j^(m+1) defd\nbegincases\nalpha_r  m = 02ex\ndisplaystyle\nfracalpha_r^(m) - alpha_r-1^(m)(t_r+k-1-t_r)(k-m)  m  0\nendcases\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Comparing with de Boor's algorithm, above, eqrefeqndBX16 is very similar in structure to eqrefeqndBX26, which means for calculating the mth derivative, we can apply eqrefeqndBX16 for jin1m, and then switch to eqrefeqndBX26 for jinm+1k-1.","category":"page"},{"location":"bsplines/theory/#Solving-equations-1","page":"Theory","title":"Solving equations","text":"","category":"section"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"For any equation of the form","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\noperatorLf = g\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"where operatorL is a linear functional, we can solve the equation approximately by expanding f and g in terms of B-splines:","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\nf = sum_j ketBjkf_j defd Bvecf\ng = sum_j ketBjkg_j defd Bvecg\nendaligned\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"where","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nB defd bmatketB1k  ketB2k  dots  ketBnk\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"The equation is now transformed to","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\noperatorLBvecf = Bvecg\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"The right-hand side is trivially in the space spaceP_tk, whereas is not necessary true for the left-hand side, i.e. the functional operatorL may take f out of the space. We can project the equation into the space spaceP_tk by left-multiplying by the projector BB^H:","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\nBB^HoperatorLBvecf = BB^HBvecg\niff\nBmatLvecf = BmatSvecg\nendaligned\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"where","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginaligned\nmatL defd B^HoperatorLB\nmatS defd B^HB\nendaligned","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Since, although the B-splines are non-orthogonal, they are linearly independent, the equation has to hold for any ketBik, and we get","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nmatLvecf = matSvecg\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"If for instance, g=lambda f, we get","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\n(matL-lambdamatS)vecf = 0\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"which is a generalized eigenvalue problem, which can be solved using e.g. ArnoldiMethod.jl.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"If instead we want to calculate a derivative of f, i.e. operatorL=partial^m, we find the vector of expansion coefficients for g as","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nvecg = matS^-1matD^(m)vecf\nendequation","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"where matD^(m) defd B^Hpartial^mB, the elements of which are calculated according to Derivatives.","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"Finally, if we want to solve a boundary-value problem, the solution is given by","category":"page"},{"location":"bsplines/theory/#","page":"Theory","title":"Theory","text":"beginequation\nvecf = matL^-1matSvecg\nendequation","category":"page"},{"location":"bsplines/differentiation/#Differentiating-functions-1","page":"Differentiating functions","title":"Differentiating functions","text":"","category":"section"},{"location":"bsplines/differentiation/#","page":"Differentiating functions","title":"Differentiating functions","text":"We proceed as indicated in Solving equations:","category":"page"},{"location":"bsplines/differentiation/#","page":"Differentiating functions","title":"Differentiating functions","text":"julia> function find_second_derivative(B, f::Function)\n           S = B'B\n           D = Derivative(axes(B,1))\n           ∇² = B'D'D*B\n\n           # Project function onto B-spline basis\n           cf = B \\ f\n           # Find derivative\n           cg = S \\ ∇²*cf\n\n           cf,cg\n       end\nfind_second_derivative (generic function with 1 method)\n\njulia> t = LinearKnotSet(10, 0, 10, 30);\n\njulia> B = BSpline(t)[:,2:end-1]\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 10 on 0.0..10.0 (30 intervals), restricted to basis functions 2..38 ⊂ 1..39","category":"page"},{"location":"bsplines/differentiation/#","page":"Differentiating functions","title":"Differentiating functions","text":"Until other boundary conditions are implemented (see note under Ordinary differential equations), second order derivatives can only be reliably computed for functions which vanish on the boundaries:","category":"page"},{"location":"bsplines/differentiation/#","page":"Differentiating functions","title":"Differentiating functions","text":"julia> cf,cg = find_second_derivative(B, x -> sin(2π*x))\n([0.233234, 0.695737, 1.29447, 1.39553, -0.243123, -3.89321, 0.674553, 5.76264, -5.77088, -0.0104052  …  0.0104052, 5.77088, -5.76264, -0.674553, 3.89321, 0.243123, -1.39553, -1.29447, -0.695737, -0.233234], [-9.54927, -26.7923, -52.0097, -54.1103, 8.69076, 154.459, -27.2137, -227.101, 227.581, 0.568577  …  -0.568577, -227.581, 227.101, 27.2137, -154.459, -8.69076, 54.1103, 52.0097, 26.7923, 9.54927])","category":"page"},{"location":"bsplines/differentiation/#","page":"Differentiating functions","title":"Differentiating functions","text":"(Image: Derivative of sine function)","category":"page"},{"location":"bsplines/usage/#Usage-1","page":"Basis creation","title":"Usage","text":"","category":"section"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"We first load the package","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"using CompactBases","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"Then we define a linearly spaced knot set between 0 and 1 with five intervals and cubic splines. By default, full multiplicity of the endpoints is assumed.","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"julia> t = LinearKnotSet(4, 0, 1, 5)\n12-element LinearKnotSet{4,4,4,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.2\n 0.4\n 0.6\n 0.8\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> B = BSpline(t)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (5 intervals)\n\njulia> size(B)\n(ContinuumArrays.AlephInfinity{1}(), 8)","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"The last statement means that B is a quasimatrix with a continuous first dimension which is spanned by 8 basis functions.","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"The overlap matrix is created simply:","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"julia> S = B'B\n8×8 BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:\n 0.0285714    0.0175      0.00369048  0.000238095  …   ⋅           ⋅           ⋅\n 0.0175       0.0442857   0.03125     0.00690476       ⋅           ⋅           ⋅\n 0.00369048   0.03125     0.0653571   0.0449206       3.96825e-5   ⋅           ⋅\n 0.000238095  0.00690476  0.0449206   0.095873        0.00474206  5.95238e-5   ⋅\n  ⋅           5.95238e-5  0.00474206  0.0472619       0.0449206   0.00690476  0.000238095\n  ⋅            ⋅          3.96825e-5  0.00474206   …  0.0653571   0.03125     0.00369048\n  ⋅            ⋅           ⋅          5.95238e-5      0.03125     0.0442857   0.0175\n  ⋅            ⋅           ⋅           ⋅              0.00369048\n  0.0175      0.0285714","category":"page"},{"location":"bsplines/usage/#Number-of-quadrature-points-1","page":"Basis creation","title":"Number of quadrature points","text":"","category":"section"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"As explained in the theory section on Integrals, Gauß–Legendre quadrature is used to approximate integrals between B-splines. It is possible to decide how many quadrature points are used by passing an argument to the BSpline constructor:","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"julia> B = BSpline(t,4)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (5 intervals)","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"If too few quadrature points are specified, a warning is issued:","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"julia> B = BSpline(t,3)\n┌ Warning: N = 3 quadrature points not enough to calculate overlaps between polynomials of order k = 4\n└ @ CompactBases ~/.julia/dev/CompactBases/src/quadrature.jl:48\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (5 intervals)","category":"page"},{"location":"bsplines/usage/#Dual-bases-1","page":"Basis creation","title":"Dual bases","text":"","category":"section"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"It is sometimes useful to work with dual bases, e.g. B-splines of different orders. This is possible as long as both bases are resolved on the same quadrature points:","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"julia> tl = LinearKnotSet(3, 0, 1, 2)\n7-element LinearKnotSet{3,3,3,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}:\n 0.0\n 0.0\n 0.0\n 0.5\n 1.0\n 1.0\n 1.0\n\njulia> tr = LinearKnotSet(4, 0, 1, 2)\n9-element LinearKnotSet{4,4,4,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.5\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> N = 4\n4\n\njulia> L = BSpline(tl, N)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 3 (parabolic) on 0.0..1.0 (2 intervals)\n\njulia> R = BSpline(tr, N)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (2 intervals)\n\njulia> S = L'R\n4×5 BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:\n 0.0833333   0.0645833   0.0166667  0.00208333   ⋅\n 0.0375      0.129167    0.108333   0.0541667   0.00416667\n 0.00416667  0.0541667   0.108333   0.129167    0.0375\n 0.0         0.00208333  0.0166667  0.0645833   0.0833333","category":"page"},{"location":"bsplines/usage/#Evaluation-of-B-splines-1","page":"Basis creation","title":"Evaluation of B-splines","text":"","category":"section"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"It is the possible to query the values of e.g. the first basis functions at some values of x:","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"julia> B[0:0.1:1,1]\n11-element SparseArrays.SparseVector{Float64,Int64} with 2 stored entries:\n  [1 ]  =  1.0\n  [2 ]  =  0.125","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"We can also evaluate all the B-splines at the same time:","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"julia> B[0:0.25:1,:]\n5×8 SparseArrays.SparseMatrixCSC{Float64,Int64} with 14 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  0.105469\n  [2, 3]  =  0.576823\n  [3, 3]  =  0.0208333\n  [2, 4]  =  0.315104\n  [3, 4]  =  0.479167\n  [4, 4]  =  0.00260417\n  [2, 5]  =  0.00260417\n  [3, 5]  =  0.479167\n  [4, 5]  =  0.315104\n  [3, 6]  =  0.0208333\n  [4, 6]  =  0.576823\n  [4, 7]  =  0.105469\n  [5, 8]  =  1.0","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"Since the B-splines have compact support, they are only locally non-zero, hence the sparse storage.","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"Finally, we can compute the value of a single B-spline, a range, or all of them at a single point x:","category":"page"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"julia> B[0.5,4]\n0.47916666666666674\n\njulia> B[0.5,:]\n8-element Array{Float64,1}:\n 0.0\n 0.0\n 0.020833333333333325\n 0.47916666666666674\n 0.4791666666666666\n 0.020833333333333322\n 0.0\n 0.0\n\njulia> B[0.5,4:8]\n5-element Array{Float64,1}:\n 0.47916666666666674\n 0.4791666666666666\n 0.020833333333333322\n 0.0\n 0.0","category":"page"},{"location":"bsplines/usage/#Reference-1","page":"Basis creation","title":"Reference","text":"","category":"section"},{"location":"bsplines/usage/#","page":"Basis creation","title":"Basis creation","text":"BSpline\nBSpline(t::CompactBases.AbstractKnotSet, N)\nBSpline(t::CompactBases.AbstractKnotSet; k′=3)","category":"page"},{"location":"bsplines/usage/#CompactBases.BSpline","page":"Basis creation","title":"CompactBases.BSpline","text":"BSpline(t, x, w, B, S)\n\nBasis structure for the B-splines generated by the knot set t. x and w are the associated quadrature roots and weights, respectively, the columns of B correspond to the B-splines resolved on the quadrature roots, and S is the (banded) B-spline overlap matrix.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/usage/#CompactBases.BSpline-Tuple{CompactBases.AbstractKnotSet,Any}","page":"Basis creation","title":"CompactBases.BSpline","text":"BSpline(t[, N])\n\nCreate the B-spline basis corresponding to the knot set t. N is the amount of Gauß–Legendre quadrature points per interval.\n\n\n\n\n\n","category":"method"},{"location":"bsplines/usage/#CompactBases.BSpline-Tuple{CompactBases.AbstractKnotSet}","page":"Basis creation","title":"CompactBases.BSpline","text":"BSpline(t[; k′=3])\n\nCreate the B-spline basis corresponding to the knot set t. k′ is the highest polynomial order of operators for which it should be possible to compute the matrix elements exactly (via Gauß–Legendre quadrature). The default k′=3 corresponds to operators O(x²).\n\n\n\n\n\n","category":"method"},{"location":"diagonal_operators/#Diagonal-operators-1","page":"Diagonal operators","title":"Diagonal operators","text":"","category":"section"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"Diagonal operators are operators (functionals) that only depend on the coordinate; they are also called local operators. They act on a function to produce a new function as","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"L f(x) = f(x)g(x)","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"Typical examples are potentials, such as the Coulomb potential V(x) = Qx, generated by a charge Q. This potential is not polynomial, i.e. we cannot compute its matrix elements exactly using Gauß quadratures, but with high enough order and intelligent placement of the nodes, we can get sufficient accuracy.","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"In orthogonal bases, such as finite-differences and FE-DVR diagonal operators are represented by diagonal matrices, whose elements coincide with the values of the function evaluated at the nodes, whereas in B-splines they are banded (with the bandwidth decided by the polynomial order).","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"We can construct diagonal operators in two ways:","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"From a scalar-valued function\nFrom a vector of expansion coefficients","category":"page"},{"location":"diagonal_operators/#Construction-from-scalar-valued-function-1","page":"Diagonal operators","title":"Construction from scalar-valued function","text":"","category":"section"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"The first way consists of constructing a QuasiDiagonal object representing the function broadcast along the continuous dimension of our quasimatrix:","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"julia> f = x -> sin(2π*x);\n\njulia> rmax,k,N = 10.0,7,71;\n\njulia> r = Inclusion(0..rmax)\nInclusion(0.0..10.0)\n\njulia> qf = QuasiDiagonal(f.(r))\nQuasiDiagonal{Float64,QuasiArrays.BroadcastQuasiArray{Float64,1,var\"#3824#3825\",Tuple{Inclusion{Float64,IntervalSets.Interval{:closed,:closed,Float64}}}}}(QuasiArrays.BroadcastQuasiArray{Float64,1,var\"#3824#3825\",Tuple{Inclusion{Float64,IntervalSets.Interval{:closed,:closed,Float64}}}}(var\"#3824#3825\"(), (Inclusion(0.0..10.0),)))","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"We can then project this onto a specific basis:","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"julia> R = FiniteDifferences(1:N, rmax/(N+1))\nFinite differences basis {Float64} on 0.0..10.0 with 71 points spaced by Δx = 0.1388888888888889\n\njulia> F = R'*qf*R\n71×71 Diagonal{Float64,Array{Float64,1}}:\n 0.766044   ⋅         ⋅     ⋅         ⋅          ⋅          ⋅        …   ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅        0.984808   ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅        0.5    ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅   -0.34202    ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅       -0.939693    ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅        -0.866025    ⋅        …   ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅        -0.173648      ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅        …   ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅        …   ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n ⋮                                              ⋮                    ⋱            ⋮                                              ⋮\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅        …   ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅        …   ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅           0.173648   ⋅         ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅        …   ⋅        0.866025   ⋅         ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅        0.939693   ⋅         ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅        0.34202    ⋅     ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅       -0.5    ⋅          ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅            ⋅         ⋅         ⋅         ⋅         ⋅   -0.984808    ⋅\n  ⋅         ⋅         ⋅     ⋅         ⋅          ⋅          ⋅        …   ⋅         ⋅         ⋅         ⋅         ⋅     ⋅        -0.766044","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"As indicated above, for uniform finite-differences the matrix elements coincide with the function values at the nodes:","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"julia> norm(diag(F) - f.(CompactBases.locs(R)))\n0.0","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"For B-splines, the situation is complicated by the fact that the basis functions are non-orthogonal:","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"julia> R = BSpline(LinearKnotSet(k, 0, rmax, N))\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)\n\njulia> F = R'*qf*R\n77×77 BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:\n 0.000682615  0.000987306  0.00043971   8.7846e-5    8.60727e-6    3.99159e-7   …    ⋅            ⋅             ⋅             ⋅\n 0.000987306  0.00413625   0.00468984   0.00232941   0.000573453   6.82737e-5        ⋅            ⋅             ⋅             ⋅\n 0.00043971   0.00468984   0.0114273    0.0114915    0.00562534    0.00134742        ⋅            ⋅             ⋅             ⋅\n 8.7846e-5    0.00232941   0.0114915    0.021737     0.0194201     0.00849555        ⋅            ⋅             ⋅             ⋅\n 8.60727e-6   0.000573453  0.00562534   0.0194201    0.0303017     0.0226904         ⋅            ⋅             ⋅             ⋅\n 3.99159e-7   6.82737e-5   0.00134742   0.00849555   0.0226904     0.0273211    …    ⋅            ⋅             ⋅             ⋅\n 6.92763e-9   3.1258e-6    0.000131733  0.0016054    0.0074447     0.0129012         ⋅            ⋅             ⋅             ⋅\n  ⋅           4.90703e-10  7.84375e-7   4.68188e-5   0.000508687   0.000296132       ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅           8.00117e-11  1.57973e-7   1.60126e-6   -0.000368678       ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅           1.8637e-12  -8.38672e-8   -2.36173e-5        ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅          -2.00923e-11  -1.72818e-7   …    ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅           -2.22022e-11       ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅                ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅                ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅                ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅           …    ⋅            ⋅             ⋅             ⋅\n ⋮                                                                 ⋮            ⋱                              ⋮\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅                ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅                ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅                ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅                ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅           …    ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅                ⋅            ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅              -1.8637e-12    ⋅             ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅              -1.57973e-7  -8.00117e-11    ⋅             ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅              -4.68188e-5  -7.84375e-7   -4.90703e-10    ⋅\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅           …  -0.0016054   -0.000131733  -3.1258e-6    -6.92763e-9\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅              -0.00849555  -0.00134742   -6.82737e-5   -3.99159e-7\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅              -0.0194201   -0.00562534   -0.000573453  -8.60727e-6\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅              -0.021737    -0.0114915    -0.00232941   -8.7846e-5\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅              -0.0114915   -0.0114273    -0.00468984   -0.00043971\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅           …  -0.00232941  -0.00468984   -0.00413625   -0.000987306\n  ⋅            ⋅            ⋅            ⋅            ⋅             ⋅              -8.7846e-5   -0.00043971   -0.000987306  -0.000682615","category":"page"},{"location":"diagonal_operators/#Construction-from-existing-expansion-coefficients-1","page":"Diagonal operators","title":"Construction from existing expansion coefficients","text":"","category":"section"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"Now, assume that we already know f(x) expanded over the basis function B_i(x) of our basis:","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"f(x) = sum_i f_i B_i(x)\niff\nketf = sum_i f_i ketB_i\niff\nketf = Bvecf","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"where","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"B defd\nbmatketB_1  ketB_2  dots  ketB_n","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"We wish to find the matrix elements of the matrix representing the linear functional that acting on 1 gives f(x):","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"operatorL1 = f(x)","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"i.e. we are in some sense trying to solve","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"matLveco = vecf","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"for matL, where veco is the expansion coefficients of 1 in our basis.","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"The most straightforward way is via the Vandermonde matrix V","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"f(vecx) = matVvecf","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"where vecx the vector of interpolation points (quadrature nodes). The matrix elements of the linear operator are then simply computed by quadrature","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"matL_mn = matrixelB_mf(vecx)B_n","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"For the orthogonal bases, where B_m(x_k)=delta_mk, this matrix reduces to","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"matL_mn = delta_mnf(x_m)","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"as noted above.","category":"page"},{"location":"diagonal_operators/#Example-1","page":"Diagonal operators","title":"Example","text":"","category":"section"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"As an example, we consider the calculation of","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"g(r) = operatorLf(r)","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"where f(r)=r and","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"beginaligned\noperatorL = V(r) =\n(alpha r^2 + beta r)\nexp(-3r2)\n\nbegincases\nalphaapprox0314269680527354\nbetaapprox020951312035157\nendcases\nendaligned","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"which is a kind of potential that arises in Coulomb repulsion between two electrons.","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"Now assume we know the expansion coefficients of V(x) as a function in a certain basis, and we wish to turn it into a matrix that we can act on vectors of expansion coefficients of other functions. We can find this matrix using the helper object DiagonalOperator, which takes a vector of expansion coefficients and applies the Vandermonde matrix as outlined above. Additionally, it supports updating the matrix from a new set of expansion coefficients via copyto!(::DiagonalOperator, ::AbstractVector); this is useful if the vector of coefficients are updated in an iterative procedure.","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"As noted in Solving equations, when applying a matrix representation onto a vector of expansion coefficients, for non-orthogonal bases (and non-uniform finite-differences), we need to also apply the inverse of the metric (accessible for this case through CompactBases.operator_metric). This can be automated however using LinearOperator, which will apply the metric when necessary.","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"Using these two helper objects, it is very easy to construct the linear operator corresponding to V(r):","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"julia> Z = 1.0\n1.0\n\njulia> rmax = 20*(2^1.05)/Z\n41.4105969536551\n\njulia> R = BSpline(ExpKnotSet(5, -2.0, log10(rmax), 100))[:,2:end-1]\nBSpline{Float64} basis with ExpKnotSet(Float64) of order k = 5 (quartic) on 0,0.01..41.4105969536551 (100 intervals), restricted to basis functions 2..103 ⊂ 1..104\n\njulia> r = axes(R,1)\nInclusion(0.0..41.4105969536551)\n\njulia> V = r -> (0.314269680527354*r^2 + 0.20951312035157*r)*exp(-3*r/2);\n\njulia> Vc = R \\ V.(r);\n\njulia> rc = R \\ identity.(r);\n\njulia> L = DiagonalOperator(applied(*, R, Vc));\n\njulia> Lop = LinearOperator(L, R);\n\njulia> Vr = Lop*rc\n102-element Array{Float64,1}:\n -6.437293442739495e-13\n  3.798365453775743e-6\n  1.2424470533333464e-5\n  2.7121761289132286e-5\n  3.2090730029882946e-5\n  3.796988258561289e-5\n  4.492587091937226e-5\n  5.315583051008927e-5\n  6.289294839226428e-5\n  7.441303882230927e-5\n  8.804231534677851e-5\n  0.00010416656971041078\n  0.0001232420118403251\n  0.00014580806529367152\n  0.00017250246558852265\n  0.0002040790666006322\n  ⋮\n  4.161019867703719e-6\n  1.0650428611646796e-6\n  1.6261694973586933e-7\n  5.6081547869892246e-8\n -8.301480628382248e-9\n  8.10282119124874e-9\n -4.356767898816949e-9\n  2.566986109249515e-9\n -1.4952235572648308e-9\n  8.77464781994956e-10\n -5.23100919774441e-10\n  3.250499162326124e-10\n -2.2378205999333905e-10\n  1.932597252925329e-10\n -1.2790533015167562e-10\n  5.54754760432595e-11","category":"page"},{"location":"diagonal_operators/#","page":"Diagonal operators","title":"Diagonal operators","text":"(Image: Diagonal operators)","category":"page"},{"location":"inner_products/#Inner-products-and-norms-1","page":"Inner products & norms","title":"Inner products & norms","text":"","category":"section"},{"location":"inner_products/#Inner-products-1","page":"Inner products & norms","title":"Inner products","text":"","category":"section"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"The inner product of two functions is simply computed as","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"julia> B = FiniteDifferences(10, 0.1)\nFinite differences basis {Float64} on 0.0..1.1 with 10 points spaced by Δx = 0.1\n\njulia> x = axes(B,1)\nInclusion(0.0..1.1)\n\njulia> c = B \\ sin.(2π*x)\n10-element Array{Float64,1}:\n  0.5877852522924731\n  0.9510565162951535\n  0.9510565162951536\n  0.5877852522924732\n  1.2246467991473532e-16\n -0.587785252292473\n -0.9510565162951535\n -0.9510565162951536\n -0.5877852522924734\n -2.4492935982947064e-16\n\njulia> f = B*c\nQuasiArrays.ApplyQuasiArray{Float64,1,typeof(*),Tuple{FiniteDifferences{Float64,Int64},Array{Float64,1}}}(*, (Finite differences basis {Float64} on 0.0..1.1 with 10 points spaced by Δx = 0.1, [0.5877852522924731, 0.9510565162951535, 0.9510565162951536, 0.5877852522924732, 1.2246467991473532e-16, -0.587785252292473, -0.9510565162951535, -0.9510565162951536, -0.5877852522924734, -2.4492935982947064e-16]))\n\njulia> d = B \\ cos.(2π*x)\n10-element Array{Float64,1}:\n  0.8090169943749475\n  0.30901699437494745\n -0.30901699437494734\n -0.8090169943749473\n -1.0\n -0.8090169943749475\n -0.30901699437494756\n  0.30901699437494723\n  0.8090169943749473\n  1.0\n\njulia> g = B*d\nQuasiArrays.ApplyQuasiArray{Float64,1,typeof(*),Tuple{FiniteDifferences{Float64,Int64},Array{Float64,1}}}(*, (Finite differences basis {Float64} on 0.0..1.1 with 10 points spaced by Δx = 0.1, [0.8090169943749475, 0.30901699437494745, -0.30901699437494734, -0.8090169943749473, -1.0, -0.8090169943749475, -0.30901699437494756, 0.30901699437494723, 0.8090169943749473, 1.0]))\n\njulia> f'f\n0.5000000000000001\n\njulia> f'g\n-3.0044051106072847e-17\n\njulia> g'g\n0.5","category":"page"},{"location":"inner_products/#Norms-1","page":"Inner products & norms","title":"Norms","text":"","category":"section"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"Similarly, norms are easily computed as","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"julia> norm(f)\n0.7071067811865476\n\njulia> norm(g)\n0.7071067811865476","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"For orthogonal bases, other p-norms are also available:","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"julia> norm(g,1)\n0.647213595499958\n\njulia> norm(g,Inf)\n1.0","category":"page"},{"location":"inner_products/#Caveats-for-non-orthogonal-bases-1","page":"Inner products & norms","title":"Caveats for non-orthogonal bases","text":"","category":"section"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"Also for B-splines, the inner products and norms can be computed as above:","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"julia> R = BSpline(LinearKnotSet(7, 0.0, 1.0, 3))[:,2:end-1]\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (3 intervals), restricted to basis functions 2..8 ⊂ 1..9\n\njulia> r = axes(R,1)\nInclusion(0.0..1.0)\n\njulia> c = R \\ sin.(2π*r)\n7-element Array{Float64,1}:\n  0.35236622516315186\n  1.0329925571692269\n  1.6856805930016943\n -5.528339670985388e-16\n -1.6856805930016923\n -1.0329925571692293\n -0.35236622516315186\n\njulia> f = R*c\nSpline on BSpline{Float64} basis with LinearKnotSet(Float64) of order\nk = 7 on 0.0..1.0 (3 intervals)\n\njulia> f'f\n0.4999507480992042\n\njulia> norm(f)\n0.7070719539758342","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"For unrestricted bases, the metric is stored in the B-spline basis object. Beware though, when working with Restricted bases, the metric needs to be recomputed every time an inner product is computed.","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"julia> @benchmark f'f\nBenchmarkTools.Trial:\n  memory estimate:  928 bytes\n  allocs estimate:  25\n  --------------\n  minimum time:     5.112 μs (0.00% GC)\n  median time:      5.536 μs (0.00% GC)\n  mean time:        6.227 μs (2.44% GC)\n  maximum time:     1.539 ms (98.89% GC)\n  --------------\n  samples:          10000\n  evals/sample:     6\n\njulia> @benchmark norm(f)\nBenchmarkTools.Trial:\n  memory estimate:  944 bytes\n  allocs estimate:  26\n  --------------\n  minimum time:     5.163 μs (0.00% GC)\n  median time:      5.605 μs (0.00% GC)\n  mean time:        6.209 μs (2.26% GC)\n  maximum time:     1.415 ms (99.13% GC)\n  --------------\n  samples:          10000\n  evals/sample:     6","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"When working with non-orthogonal basis functions, such as B-splines, it is therefore advised to explicitly compute the metric once and use that for all inner products and norms:","category":"page"},{"location":"inner_products/#","page":"Inner products & norms","title":"Inner products & norms","text":"julia> S = R'R\n7×7 BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:\n 0.0368555    0.0285178   0.0102464    0.00267575  0.000472084  4.3428e-5   2.70996e-8\n 0.0285178    0.0492836   0.0347641    0.0176553   0.00640938   0.00142346  4.3428e-5\n 0.0102464    0.0347641   0.0402597    0.0319871   0.0180037    0.00640938  0.000472084\n 0.00267575   0.0176553   0.0319871    0.0380685   0.0319871    0.0176553   0.00267575\n 0.000472084  0.00640938  0.0180037    0.0319871   0.0402597    0.0347641   0.0102464\n 4.3428e-5    0.00142346  0.00640938   0.0176553   0.0347641    0.0492836   0.0285178\n 2.70996e-8   4.3428e-5   0.000472084  0.00267575  0.0102464    0.0285178   0.0368555\n\njulia> @benchmark dot(c,S,c)\nBenchmarkTools.Trial:\n  memory estimate:  16 bytes\n  allocs estimate:  1\n  --------------\n  minimum time:     80.383 ns (0.00% GC)\n  median time:      88.495 ns (0.00% GC)\n  mean time:        98.239 ns (1.42% GC)\n  maximum time:     6.183 μs (98.38% GC)\n  --------------\n  samples:          10000\n  evals/sample:     944","category":"page"},{"location":"bsplines/operators/#Approximating-operators-1","page":"Approximating operators","title":"Approximating operators","text":"","category":"section"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"As mentioned in Solving equations, the action of a linear operator on a spline can be approximated by projecting the operator into the space spaceP_tk: matLdefd B^HoperatorLB. We can employ this for different kinds of operators; out-of-the-box, CompactBases.jl supports differential operators and diagonal operators:","category":"page"},{"location":"bsplines/operators/#Differential-operators-1","page":"Approximating operators","title":"Differential operators","text":"","category":"section"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"In the ContinuumArrays framework, differential operators are represented by the Derivative operator, which operates in a domain (typically the first axis of an ContinuumArrays.QuasiArrays.AbstractQuasiMatrix, e.g. a ContinuumArrays.Basis such as BSpline):","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"julia> using CompactBases\n\njulia> B = BSpline(LinearKnotSet(3, 0, 1, 3))\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 3 (parabolic) on 0.0..1.0 (3 intervals)\n\njulia> D = Derivative(axes(B,1))\nDerivative{Float64,IntervalSets.Interval{:closed,:closed,Float64}}(ContinuumArrays.QuasiArrays.Inclusion{Float64,IntervalSets.Interval{:closed,:closed,Float64}}(0.0..1.0))","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"The derivative operator can then be projected into the space generated by the knot set t by","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"julia> ∇ = B'D*B\n5×5 BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:\n -0.5         0.416667      0.0833333      ⋅            ⋅\n -0.416667    2.07997e-17   0.375         0.0416667     ⋅\n -0.0833333  -0.375         7.84759e-17   0.375        0.0833333\n   ⋅         -0.0416667    -0.375        -1.31839e-16  0.416667\n   ⋅           ⋅           -0.0833333    -0.416667     0.5","category":"page"},{"location":"bsplines/operators/#Diagonal-operators-1","page":"Approximating operators","title":"Diagonal operators","text":"","category":"section"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"Diagonal operators are operators that only depend on the coordinate; they are also called local operators. Typical examples are potentials, such as the Coulomb potential V(x) = Qx, generated by a charge Q. This potential is not polynomial, i.e. we cannot compute its matrix elements exactly using Gauß–Legendre quadrature, but with high enough order and intelligent placement of the knots, we can get sufficient accuracy.","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"Diagonal operators are projected into the B-spline space using the Matrix function:","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"LinearAlgebra.Matrix","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"As as example of the importance of knot placement, we study the action of the Coulomb operator operatorV(x) = -1x on the function f(x)=x^2exp(-x); we know that the result should be g(x)=operatorV(x)f(x)=-xexp(-x):","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"julia> k = 7\n7\n\njulia> N = 31\n31\n\njulia> a,b = 0,70\n(0, 70)\n\njulia> coulomb(r) = -1/r\ncoulomb (generic function with 1 method)\n\njulia> tlin = LinearKnotSet(k, a, b, N);\n\njulia> texp = ExpKnotSet(k, -1.0, log10(b), N);\n\njulia> Blin = BSpline(tlin,3)[:,2:end-1]\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..70.0 (31 intervals), restricted to basis functions 2..36 ⊂ 1..37\n\njulia> Bexp = BSpline(texp,3)[:,2:end-1]\nBSpline{Float64} basis with ExpKnotSet(Float64) of  on order k = 7 on 0,0.1..70.00000000000001 (31 intervals), restricted to basis functions 2..36 ⊂ 1..37","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"Then, for B=Blin and B=Bexp, we do the following:","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"S = B'B\nf = B \\ x -> x^2*exp(-x)\nV = Matrix(coulomb, B)\ng̃ = S \\ V*f","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"and obtain two different approximations g̃ to g(x), as shown in the following plot:","category":"page"},{"location":"bsplines/operators/#","page":"Approximating operators","title":"Approximating operators","text":"(Image: Coulomb operator)","category":"page"},{"location":"bsplines/odes/#Ordinary-differential-equations-1","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"","category":"section"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"It is easy to solve ordinary differential equations using B-splines, as long as they are linear. For non-linear ODEs, the simplest way is most likely to linearize the equations, solve the resulting equation system (as illustrated below), and combining this with fixed-point iteration or Newton's method.","category":"page"},{"location":"bsplines/odes/#Hooke's-law-1","page":"Ordinary differential equations","title":"Hooke's law","text":"","category":"section"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"A spring that is extended from its equilibrium point by x experiences a restoring force","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"beginequation\nF = -kx\nendequation","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"where k is the spring constant. The potential energy of the spring is related to the force as","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"beginequation\nF = -nabla V(x)\nendequation","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"We can find this potential by solving a boundary value problem, expanding F in B-splines. Since we do not know the values of V(x) at the edges of the domain, we can employ the fact that the restoring force is antisymmetric and that V(0)=0, and solve the problem on the half-domain 0x_textrmmax. This turns the problem into an initial-value problem.","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"We proceed as indicated in Solving equations:","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"julia> function ode_hookes_law(xₘₐₓ, kspring, k, N)\n           t = LinearKnotSet(k, 0, xₘₐₓ, N)\n           # By omitting the first basis function, we enforce V(0) = 0\n           B = BSpline(t)[:,2:end]\n           S = B'B\n\n           D = Derivative(axes(B, 1))\n           ∇ = B'D*B\n\n           # Hooke's law\n           F = x -> -kspring*x\n\n           # Expand Hooke's law on B-splines\n           cF = B \\ F\n           # Solve for expansion coefficients of potential\n           cV = -∇ \\ S*cF\n\n           cF,cV\n       end\n\njulia> cF,cV = ode_hookes_law(3, 0.1, 7, 30)\n([-0.00166667, -0.005, -0.01, -0.0166667, -0.025, -0.035, -0.045, -0.055, -0.065, -0.075  …  -0.235, -0.245, -0.255, -0.265, -0.275, -0.283333, -0.29, -0.295, -0.298333, -0.3], [2.90458e-16, 6.66667e-5, 0.000366667, 0.00116667, 0.00283333, 0.00583333, 0.00983333, 0.0148333, 0.0208333, 0.0278333  …  0.275833, 0.299833, 0.324833, 0.350833, 0.377833, 0.401167, 0.420367, 0.435067, 0.445, 0.45])","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"We can compare the approximation with the exact potential, given by","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"beginequation\nV(x) = frackx^22\nendequation","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"(Image: Hooke's law and harmonic potential)","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"However, since the restoring force is linear, the potential can at most be quadratic; furthermore, we only need one interval to solve the problem exactly:","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"julia> cF,cV = ode_hookes_law(3, 0.1, 3, 1)\n([-0.15, -0.3], [0.0, 0.45])","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"(Image: Hooke's law and harmonic potential)","category":"page"},{"location":"bsplines/odes/#","page":"Ordinary differential equations","title":"Ordinary differential equations","text":"note: Note\nOther boundary conditions, such as y(a)=alpha, or y(a)=beta, do not yet have a simple implementation. This mean that it is not convenient (but not impossible) to solve boundary-value problems with other boundary conditions than y(a)=y(b)=0, or initial-value problems with other initial values than y(a)=0.","category":"page"},{"location":"bsplines/knot_sets/#Knot-sets-1","page":"Knot sets","title":"Knot sets","text":"","category":"section"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"Three built-in knot sets are provided out-of-the-box:","category":"page"},{"location":"bsplines/knot_sets/#Arbitrary-knot-set-1","page":"Knot sets","title":"Arbitrary knot set","text":"","category":"section"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"Arbitrary knot sets allow custom placement of the individual knots, as well as custom multiplicity of interior knots. This can be used for problems where discontinuity at a certain location is desired.","category":"page"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"ArbitraryKnotSet\nArbitraryKnotSet(k::Integer, t::AbstractVector, ml::Integer=k, mr::Integer=k)","category":"page"},{"location":"bsplines/knot_sets/#CompactBases.ArbitraryKnotSet","page":"Knot sets","title":"CompactBases.ArbitraryKnotSet","text":"ArbitraryKnotSet{k,ml,mr}(t)\n\nAn arbitrary knot set of order k and left and right multiplicities of ml and mr, respectively. The knot set is specified by the non-decreasing vector t; the same knot may appear multiple times, which influences the continuity of the B-splines at that location.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/knot_sets/#CompactBases.ArbitraryKnotSet","page":"Knot sets","title":"CompactBases.ArbitraryKnotSet","text":"ArbitraryKnotset(k, t[, ml=k, mr=k])\n\nConstruct an order-k arbitrary knot set, with the locations of the knots given by non-decreasing vector t.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/knot_sets/#Linear-knot-set-1","page":"Knot sets","title":"Linear knot set","text":"","category":"section"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"LinearKnotSet\nLinearKnotSet(k::Integer, a, b, N::Integer, ml::Integer=k, mr::Integer=k)","category":"page"},{"location":"bsplines/knot_sets/#CompactBases.LinearKnotSet","page":"Knot sets","title":"CompactBases.LinearKnotSet","text":"LinearKnotSet{k,ml,mr}(t)\n\nA knot set of order k and left and right multiplicities of ml and mr, respectively, whose knots are uniformly distributed according to the range t. The interior basis functions are thus Cᵏ⁻²-continuous.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/knot_sets/#CompactBases.LinearKnotSet","page":"Knot sets","title":"CompactBases.LinearKnotSet","text":"LinearKnotSet(k, a, b, N[, ml=k, mr=k])\n\nConstruct an order-k linear knot set spanning from a to b, with N intervals.\n\nExamples\n\njulia> LinearKnotSet(2, 0, 1, 3)\n6-element LinearKnotSet{2,2,2,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}:\n 0.0\n 0.0\n 0.3333333333333333\n 0.6666666666666666\n 1.0\n 1.0\n\n\n\n\n\n","category":"type"},{"location":"bsplines/knot_sets/#Exponential-knot-set-1","page":"Knot sets","title":"Exponential knot set","text":"","category":"section"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"Exponential knot sets are useful for approximating exponentially varying functions (e.g. bound states of atoms). The quadrature points of each interval are distributed as were the knot set piecewise linear.","category":"page"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"ExpKnotSet\nExpKnotSet(k::Integer, a::T, b::T, N::Integer, ml::Integer=k, mr::Integer=k; base::T=T(10), include0::Bool=true) where T","category":"page"},{"location":"bsplines/knot_sets/#CompactBases.ExpKnotSet","page":"Knot sets","title":"CompactBases.ExpKnotSet","text":"ExpKnotSet{k,ml,mr}(exponents, base, t, include0)\n\nA knot set of order k and left and right multiplicities of ml and mr, respectively, whose knots are exponentially distributed according to t = base .^ exponents, optionally including 0 as the left endpoint.\n\n\n\n\n\n","category":"type"},{"location":"bsplines/knot_sets/#CompactBases.ExpKnotSet-Union{Tuple{T}, Tuple{Integer,T,T,Integer}, Tuple{Integer,T,T,Integer,Integer}, Tuple{Integer,T,T,Integer,Integer,Integer}} where T","page":"Knot sets","title":"CompactBases.ExpKnotSet","text":"ExpKnotSet(k, a, b, N[, ml=k, mr=k, base=10, include0=true])\n\nConstruct an order-k knot spanning from base^a to base^b in N intervals, optionally including 0 as the left endpoint.\n\nExamples\n\njulia> ExpKnotSet(2, -4, 2, 7)\n10-element ExpKnotSet{2,2,2,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Array{Float64,1}}:\n   0.0\n   0.0\n   0.0001\n   0.001\n   0.01\n   0.1\n   1.0\n  10.0\n 100.0\n 100.0\n\n\n\n\n\n","category":"method"},{"location":"bsplines/knot_sets/#Reference-1","page":"Knot sets","title":"Reference","text":"","category":"section"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"order\nnumintervals\nnumfunctions\nfirst\nlast\nlength\ngetindex\nnonempty_intervals","category":"page"},{"location":"bsplines/knot_sets/#CompactBases.order","page":"Knot sets","title":"CompactBases.order","text":"order(t)\n\nReturns the order k of the knot set t.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.numintervals","page":"Knot sets","title":"CompactBases.numintervals","text":"numinterval(t)\n\nReturns the number of intervals generated by the knot set t.\n\nExamples\n\njulia> numintervals(LinearKnotSet(3, 0, 1, 2))\n2\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.numfunctions","page":"Knot sets","title":"CompactBases.numfunctions","text":"numfunctions(t)\n\nReturns the number of basis functions generated by knot set t.\n\nExamples\n\njulia> numfunctions(LinearKnotSet(3, 0, 1, 2))\n4\n\njulia> numfunctions(LinearKnotSet(5, 0, 1, 2))\n6\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#Base.first","page":"Knot sets","title":"Base.first","text":"first(t)\n\nReturn the first knot of t.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#Base.last","page":"Knot sets","title":"Base.last","text":"last(t)\n\nReturn the last knot of t.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#Base.length","page":"Knot sets","title":"Base.length","text":"length(t)\n\nReturn the number of knots of t.\n\nExamples\n\njulia> length(LinearKnotSet(3, 0, 1, 3))\n8\n\njulia> length(LinearKnotSet(3, 0, 1, 3, 1, 1))\n4\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#Base.getindex","page":"Knot sets","title":"Base.getindex","text":"getindex(t, i)\n\nReturn the ith knot of the knot set t, accounting for the multiplicities of the endpoints.\n\nExamples\n\njulia> LinearKnotSet(3, 0, 1, 3)[2]\n0.0\n\njulia> LinearKnotSet(3, 0, 1, 3, 1, 1)[2]\n0.3333333333333333\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.nonempty_intervals","page":"Knot sets","title":"CompactBases.nonempty_intervals","text":"nonempty_intervals(t)\n\nReturn the indices of all intervals of the knot set t that are non-empty.\n\nExamples\n\njulia> nonempty_intervals(ArbitraryKnotSet(3, [0.0, 1, 1, 3, 4, 6], 1, 3))\n4-element Array{Int64,1}:\n 1\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#Internals-1","page":"Knot sets","title":"Internals","text":"","category":"section"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"CompactBases.AbstractKnotSet\nCompactBases.assert_multiplicities\nCompactBases.leftmultiplicity\nCompactBases.rightmultiplicity\nCompactBases.find_interval\nCompactBases.within_interval\nCompactBases.within_support","category":"page"},{"location":"bsplines/knot_sets/#CompactBases.AbstractKnotSet","page":"Knot sets","title":"CompactBases.AbstractKnotSet","text":"AbstractKnotSet{k,ml,mr,T}\n\nAbstract base for B-spline knot sets. T is the eltype of the knot set, k is the order of the piecewise polynomials (order = degree + 1) and ml and mr are the knot multiplicities of the left and right endpoints, respectively.  \n\n\n\n\n\n","category":"type"},{"location":"bsplines/knot_sets/#CompactBases.assert_multiplicities","page":"Knot sets","title":"CompactBases.assert_multiplicities","text":"assert_multiplicities(k,ml,mr,t)\n\nAssert that the multiplicities at the endpoints, ml and mr, respectively, are consistent with the order k. Also check that the amount of knots in the knot set t are enough to support the requested order k.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.leftmultiplicity","page":"Knot sets","title":"CompactBases.leftmultiplicity","text":"leftmultiplicity(t)\n\nReturn the multiplicity of the left endpoint.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.rightmultiplicity","page":"Knot sets","title":"CompactBases.rightmultiplicity","text":"rightmultiplicity(t)\n\nReturn the multiplicity of the right endpoint.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.find_interval","page":"Knot sets","title":"CompactBases.find_interval","text":"find_interval(t, x[, i=ml])\n\nFind the interval in the knot set t that includes x, starting from interval i (which by default is the first non-zero interval of the knot set). The search complexity is linear, but by storing the result and using it as starting point for the next call to find_interval, the knot set need only be traversed once.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.within_interval","page":"Knot sets","title":"CompactBases.within_interval","text":"within_interval(x, interval)\n\nReturn the indices of the elements of x that lie within the given interval.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.within_support","page":"Knot sets","title":"CompactBases.within_support","text":"within_support(x, t, j)\n\nReturn the indices of the elements of x that lie withing the compact support of the jth basis function (enumerated 1..n), given the knot set t. For each index of x that is covered, the index k of the interval within which x[i] falls is also returned.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#Quadrature-functions-1","page":"Knot sets","title":"Quadrature functions","text":"","category":"section"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"Gauß–Legendre quadrature can be used to exactly calculate integrals of polynomials, and very accurately the integrals of smoothly varying functions. The approximation is given by","category":"page"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"beginequation\nintlimits_a^b diffxf(x)approx\nfracb-a2sum_i=1^n w_i\nfleft(fracb-a2x_i+fraca+b2right)\nendequation","category":"page"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"where x_i are the roots of the quadrature and w_i the corresponding weights, given on the elementary interval -11.","category":"page"},{"location":"bsplines/knot_sets/#","page":"Knot sets","title":"Knot sets","text":"CompactBases.num_quadrature_points\nCompactBases.lgwt!\nCompactBases.lgwt","category":"page"},{"location":"bsplines/knot_sets/#CompactBases.num_quadrature_points","page":"Knot sets","title":"CompactBases.num_quadrature_points","text":"num_quadrature_points(k, k′)\n\nThe number of quadrature points needed to exactly compute the matrix elements of an operator of polynomial order k′ with respect to a basis of order k.\n\n\n\n\n\n","category":"function"},{"location":"bsplines/knot_sets/#CompactBases.lgwt","page":"Knot sets","title":"CompactBases.lgwt","text":"lgwt(t, N) -> (x,w)\n\nGenerate the N Gauß–Legendre quadrature roots x and associated weights w, with respect to the B-spline basis generated by the knot set t.\n\nExamples\n\njulia> CompactBases.lgwt(LinearKnotSet(2, 0, 1, 3), 2)\n([0.0704416, 0.262892, 0.403775, 0.596225, 0.737108, 0.929558], [0.166667, 0.166667, 0.166667, 0.166667, 0.166667, 0.166667])\n\njulia> CompactBases.lgwt(ExpKnotSet(2, -4, 2, 7), 2)\n([2.11325e-5, 7.88675e-5, 0.000290192, 0.000809808, 0.00290192, 0.00809808, 0.0290192, 0.0809808, 0.290192, 0.809808, 2.90192, 8.09808, 29.0192, 80.9808], [5.0e-5, 5.0e-5, 0.00045, 0.00045, 0.0045, 0.0045, 0.045, 0.045, 0.45, 0.45, 4.5, 4.5, 45.0, 45.0])\n\n\n\n\n\n","category":"function"},{"location":"fd_non_uniform/#Non-uniform-grids-1","page":"Non-uniform grids","title":"Non-uniform grids","text":"","category":"section"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"By employing non-uniform grids, more effort can be concentrated to those parts where the function is expected to vary more, hopefully leading to a better approximation. StaggeredFiniteDifferences supports both uniform and non-uniform node distributions; in the former case, the node locations are stored as an AbstractRange, in the latter, as any other kind of AbstractVector.","category":"page"},{"location":"fd_non_uniform/#Integrals-1","page":"Non-uniform grids","title":"Integrals","text":"","category":"section"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"Since the quadrature weights in the non-uniform case are location-dependent, they are baked into to the expansion coefficients (as in the FE-DVR case), such that","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"intdiffx f(x) approx sum_i f_i","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"where f_i is the ith expansion coefficient of f(x). In the uniform case, the expansion coefficients instead equal the function value at the nodes, which means","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"intdiffx f(x) approx Delta x sum_i f_i","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"To be sure that you always get the right integration weight, use the metric to perform integrals, e.g.","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"intdiffx f(x)","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"is computed using","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"integral = sum(S*f)","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"where the metric matrix can be found using","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"S = B'B","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"Similarly, integrals of the kind","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"intdiffx conjf(x)g(x)","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"are easily computed as","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"integral = dot(f, S, g)","category":"page"},{"location":"fd_non_uniform/#Example-1","page":"Non-uniform grids","title":"Example","text":"","category":"section"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"We start by constructing two StaggeredFiniteDifferences grids, one uniform and one log–linear, of approximately the same extent (at least including r=30):","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"julia> N = 50\n50\n\njulia> rmax = 30.0\n30.0\n\njulia> B1 = StaggeredFiniteDifferences(rmax, N)\nStaggered finite differences basis {Float64} on 0.0..30.606060606060606 with 50 points spaced by ρ = 0.6060606060606061\n\njulia> ρmin = 0.001 # Min step-size\n0.001\n\njulia> ρmax = 1.0 # Max step-size\n1.0\n\njulia> α = 0.1 # Step-size change rate\n0.1\n\njulia> B2 = StaggeredFiniteDifferences(ρmin, ρmax, α, rmax)\nStaggered finite differences basis {Float64} on 0.0..31.475628188861677 with 103 points","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"As mentioned above, the metrics are different in the uniform and non-uniform cases:","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"julia> S1 = B1'B1\nUniformScaling{Float64}\n0.6060606060606061*I\n\njulia> S2 = B2'B2\nUniformScaling{Bool}\ntrue*I","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"Since the step-size is changing for non-uniform grids, step is ill-defined, but returns unity to simplify the implementation of the differential operators (the coefficients are divided by step(B)^k, where k is the order of the differential; since that is already accounted for in the case of non-uniform grids by scaling the coefficients, 1^k does not change the result):","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"julia> step(B1)\n0.6060606060606061\n\njulia> step(B2)\n1.0","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"The node locations and weights are shown in the figure below: (Image: Non-uniform grid)","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"The basis functions become asymmetric in the non-uniform case:","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"julia> # Compute basis functions on a dense grid\n       ξ = 10.0 .^ range(-3, stop=log10(25), length=1000);\n\njulia> χ1 = B1[ξ, :];\n\njulia> χ2 = B2[ξ, :];","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"(Image: Non-uniform basis functions)","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"We then expand the function","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"f(x) = sin(2pi x30)exp(-4x30)","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"on both grids and compare the error:","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"julia> f = x -> sin(2π*x/rmax)*exp(-4x/rmax)\n#47 (generic function with 1 method)\n\njulia> xx1 = axes(B1,1)\nInclusion(0.0..30.606060606060606)\n\njulia> c1 = B1 \\ f.(xx1);\n\n\njulia> xx2 = axes(B2,1)\nInclusion(0.0..31.475628188861677)\n\njulia> c2 = B2 \\ f.(xx2);\n\njulia> f1 = χ1*c1;\n\njulia> f2 = χ2*c2;\n\njulia> fe = f.(ξ);","category":"page"},{"location":"fd_non_uniform/#","page":"Non-uniform grids","title":"Non-uniform grids","text":"(Image: Non-uniform basis functions)","category":"page"},{"location":"densities/#Densities-1","page":"Densities","title":"Densities","text":"","category":"section"},{"location":"densities/#","page":"Densities","title":"Densities","text":"The mutual density between two functions f(x) and g(x) is defined as","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"(fcdot g)(x) defd conjf(x)g(x)","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"where the term density is used in analogy with density matrices in quantum mechanics, and for which reason the first function is conjugated. Without the conjugate, it is equivalent to the pointwise product.","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"The mutual density h(x) of two functions expanded over two sets of basis functions","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"beginaligned\nf(x) = sum_i f_i ketA_i \ng(x) = sum_i g_i ketB_i\nendaligned","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"can be expressed as one expansion over one set of basis functions,","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"h(x) = sum_i h_i ketC_i","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"and this can be computed using Density, as long as ketA_i and ketB_i are compatible. The space spanned by ketC_i must be able to express products of the original spaces, i.e. if f(x) and g(x) are both quadratic functions, formally h(x) will be a quartic function. There exist rather complicated algorithms for producing the expansion coefficients for the product function expanded over B-splines of higher order than the constituent     factors (see e.g. [moerken1991]), however this is rarely needed in practice since we either ","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"use enough intervals to successfully approximate the function as piecewise polynomials of lower order,\nuse high enough polynomial order of our basis functions that we can represent the factors and their product satisfactorily,\nor both of the above.","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"Therefore, we instead turn to the pragmatic approach which is based on the Vandermonde matrix: if we want to find the expansion coefficients of h(x) on the basis ketC_i, we compute the Vandermonde matrix matV_C (using vandermonde) for that basis and solve","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"matV_C vech = h(vecx)","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"where the right-hand side h(vecx) denotes the function values of h(x) on all the interpolation points (returned by locs), but these are in turn given by (fcdot g)(vecx), which we can reconstruct from the expansion coefficients of f(x) and g(x) by multiplying those by their respective Vandermonde matrices matV_A and matV_B. In total, the expansion coefficients for the product function are thus given by","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"vech =\nmatV_C^+\nmatV_A\nconjvecf\nodot\nmatV_B\nvecg","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"where matV_C^+ is the Moore–Penrose inverse of matV_C which can easily be computed using its singular-value decomposition, and odot denotes the elementwise or Hadamard product, i.e. Julia's .* product. For this to work, naturally the bases ketA_i, ketB_i, and ketC_i must share interpolation points vecx and thus their Vandermonde matrices must have the same number of rows. For simplicity, CompactBases.jl assumes that ketB_i and ketC_i are the same and that ketA_i is \"compatible\" (checked by assert_compatible_bases).","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"For orthogonal bases such as finite-difference and FE-DVR, where the Vandermonde matrix is diagonal and same for both bases, the above formula simplifies to","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"vech =\nmatV\nconjvecf\nodot\nvecg","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"and in the case of finite-differences on a uniform grid, where the expansion coefficients coincide with the function values at the interpolation points, the Vandermonde matrix reduces to the identity matrix and the product formula is simpler still:","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"vech =\nconjvecf\nodot\nvecg","category":"page"},{"location":"densities/#Example-1","page":"Densities","title":"Example","text":"","category":"section"},{"location":"densities/#","page":"Densities","title":"Densities","text":"julia> import CompactBases: applied\n\njulia> f = x -> sin(2π*x);\n\njulia> g = x -> x*exp(-x);\n\njulia> h = x -> f(x)*g(x);\n\njulia> rmax,k,N = 10.0,7,71\n(10.0, 7, 71)\n\njulia> R = BSpline(LinearKnotSet(k, 0, rmax, N))\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)\n\njulia> r = axes(R,1)\nInclusion(0.0..10.0)\n\njulia> cf = R \\ f.(r);\n\njulia> cg = R \\ g.(r);\n\njulia> ch = R \\ h.(r); # Direct expansion of density for comparison\n\njulia> ρ = Density(applied(*,R,cf), applied(*,R,cg));\n\njulia> ρ.ρ # Expansion coefficients computed via Vandermonde interpolation\n77-element Array{Float64,1}:\n  2.5990302560741227e-6\n -1.2089008321819097e-5\n  0.016650515757241868\n  0.08609474140758361\n  0.22264566607626868\n  0.28428278922020694\n  0.04487154524021238\n -0.3097583765428373\n -0.45136208173491543\n -0.23816476137564302\n  0.16360184909444878\n  0.43464800730290326\n  0.3730492731330008\n  0.046047307534972166\n -0.2846933885764034\n -0.3797631540817138\n  ⋮\n  0.002725515878867043\n  0.0015277308449457526\n -0.00041784201453291337\n -0.0016586000070113436\n -0.0015285004379182573\n -0.00041624819494116155\n  0.0007250143682327532\n  0.0011338505005407673\n  0.0007023771068706905\n -9.73144173106993e-5\n -0.0006544921666713287\n -0.0006548469749281168\n -0.0004243163194033977\n -0.00020768615644842965\n -6.69583797265351e-5\n -5.669216664398177e-10\n\njulia> norm(ρ.ρ - ch)\n1.5656487551918337e-6","category":"page"},{"location":"densities/#","page":"Densities","title":"Densities","text":"(Image: Mutual densities)","category":"page"},{"location":"densities/#Bibliography-1","page":"Densities","title":"Bibliography","text":"","category":"section"},{"location":"densities/#","page":"Densities","title":"Densities","text":"[moerken1991]: K. Mørken (1991). Some Identities for Products and Degree Raising of Splines. Constructive Approximation, 7(1), 195–208. http://dx.doi.org/10.1007/bf01888153","category":"page"},{"location":"fd_overview/#Finite-differences-overview-1","page":"Overview","title":"Finite-differences overview","text":"","category":"section"},{"location":"fd_overview/#","page":"Overview","title":"Overview","text":"At the moment, there are three variations of finite-differences implemented:","category":"page"},{"location":"fd_overview/#","page":"Overview","title":"Overview","text":"FiniteDifferences, standard, explicit, three-point stencil, uniform node distribution,\nStaggeredFiniteDifferences, explicit, variationally derived three-point stencil, both uniform and non-uniform distributions. The nodes are staggered, such that in the uniform case, they follow the formula\nr_j = (j-12)rho\nwhere rho is the step-size. This scheme is useful in polar and spherical coordinates. See\nSchafer, K. J., Gaarde, M. B., Kulander, K. C., Sheehy, B., &   DiMauro, L. F. (2000). Calculations of Strong Field Multiphoton   Processes in Alkali Metal Atoms. AIP Conference Proceedings, 525(1),   45–58. http://dx.doi.org/10.1063/1.1291925\nKrause, J. L., & Schafer, K. J. (1999). Control of THz Emission from   Stark Wave Packets. The Journal of Physical Chemistry A, 103(49),   10118–10125. http://dx.doi.org/10.1021/jp992144\nKoonin, S. E., & Meredith, D. C. (1990). Computational Physics,   FORTRAN Version. Reading, Mass: Addison-Wesley.\nfor the derivation.\nImplicitFiniteDifferences, also known as Compact Finite-Differences, where differential operators are approximated as\nvecf^(o)approxmatM_o^-1Delta_ovecf\nAt present, only three-point stencils and uniform grids are supported.\nLele, S. K. (1992). Compact Finite Difference Schemes With Spectral-Like Resolution. Journal of Computational Physics, 103(1), 16–42. http://dx.doi.org/10.1016/0021-9991(92)90324-r\nMuller, H. G. (1999). An Efficient Propagation Scheme for the Time-Dependent Schrödinger equation in the Velocity Gauge. Laser Physics, 9(1), 138–148.","category":"page"},{"location":"fd_overview/#Boundary-conditions-1","page":"Overview","title":"Boundary conditions","text":"","category":"section"},{"location":"fd_overview/#","page":"Overview","title":"Overview","text":"At the moment, support for anything but Dirichlet0 boundary conditions is lacking. Since the library was developed mostly with calculation in atomic physics in mind, there is some special support for singular Coulomb potentials built-in, which will remain there until the functionality has been sufficiently generalized.","category":"page"},{"location":"bsplines/splines/#Spline-creation-and-evaluation-1","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"","category":"section"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"A spline is constructed as a linear combination of B-splines:","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"beginequation\nlabeleqnspline\ns(x) = sum_j=1^n_tk Bjk(x)c_j defd Bvecc\nendequation","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"This is easily done as","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"julia> k = 4\n4\n\njulia> t = LinearKnotSet(k, 0, 1, 5)\n12-element LinearKnotSet{4,4,4,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.2\n 0.4\n 0.6\n 0.8\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> B = BSpline(t)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (5 intervals)\n\njulia> size(B)\n(ContinuumArrays.AlephInfinity{1}(), 8)\n\njulia> c = sin.(1:size(B,2))\n8-element Array{Float64,1}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n -0.9589242746631385\n -0.27941549819892586\n  0.6569865987187891\n  0.9893582466233818\n\njulia> s = B*c\nSpline on BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (5 intervals)","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"Naturally, we can evaluate the spline similarly to above:","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"julia> s[0.3]\n-0.28804656969083225\n\njulia> s[0.3:0.1:0.8]\n6-element Array{Float64,1}:\n -0.28804656969083225\n -0.6408357079724976\n -0.8250002333223664\n -0.8119858486932346\n -0.5856964504991202\n -0.15856643671353235","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"If many different splines sharing the same B-splines are going to be evaluated, it is usually more efficient to evaluate the basis functions once and reuse them:","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"julia> χ = B[0:0.25:1.0, :]\n5×8 SparseArrays.SparseMatrixCSC{Float64,Int64} with 14 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  0.105469\n  [2, 3]  =  0.576823\n  [3, 3]  =  0.0208333\n  [2, 4]  =  0.315104\n  [3, 4]  =  0.479167\n  [4, 4]  =  0.00260417\n  [2, 5]  =  0.00260417\n  [3, 5]  =  0.479167\n  [4, 5]  =  0.315104\n  [3, 6]  =  0.0208333\n  [4, 6]  =  0.576823\n  [4, 7]  =  0.105469\n  [5, 8]  =  1.0\n\njulia> χ*c\n5-element Array{Float64,1}:\n  0.8414709848078965\n -0.06366510061255656\n -0.8250002333223664\n -0.39601358159504896\n  0.9893582466233818","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"(Image: One-dimensional spline)","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"It is then trivial to extend this to two dimensions:","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"julia> c̃ = [sin.(1:size(B,2)) tan.(1:size(B,2))]\n8×2 Array{Float64,2}:\n  0.841471   1.55741\n  0.909297  -2.18504\n  0.14112   -0.142547\n -0.756802   1.15782\n -0.958924  -3.38052\n -0.279415  -0.291006\n  0.656987   0.871448\n  0.989358  -6.79971\n\njulia> s̃ = B*c̃\n2d spline on BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 4 (cubic) on 0.0..1.0 (5 intervals)\n\njulia> size(s̃)\n(ContinuumArrays.AlephInfinity{1}(), 2)","category":"page"},{"location":"bsplines/splines/#","page":"Spline creation & evaluation","title":"Spline creation & evaluation","text":"(Image: Two-dimensional spline)","category":"page"},{"location":"bsplines/inner_products/#Inner-products-and-norms-1","page":"Inner products and norms","title":"Inner products and norms","text":"","category":"section"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"The inner product between two splines is given by","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"beginequation\nlabeleqninner-product\nbraketstildes defd\nintdiffx conjs(x) tildes(x) approx\nsum_l w_l conjs(x_l) tildes(x_l)\nendequation","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"From the definition of a spline, we have","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"beginequation\ntagrefeqninner-product*\nbraketstildes = (Bvecc)^HBvectildec = vecc^H matS vectildec\nendequation","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"where the overlap matrix is given by","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"beginequation\nlabeleqnoverlap-matrix\nmatS_ij defd\nbraketBikBjk approx\nsum_l w_l conjBik(x_l)Bjk(x_l)\nendequation","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"When the B-spline basis is created, the B-splines are evaluated on the quadrature roots and stored in a sparse matrix, and the banded overlap matrix is formed:","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"julia> B = BSpline(LinearKnotSet(7, 0, 1, 10))\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (10 intervals)\n\njulia> B.B\n80×16 SparseArrays.SparseMatrixCSC{Float64,Int64} with 560 stored entries:\n  [1 ,  1]  =  0.886629\n  [2 ,  1]  =  0.525563\n  [3 ,  1]  =  0.196947\n  [4 ,  1]  =  0.0429226\n  [5 ,  1]  =  0.00463197\n  [6 ,  1]  =  0.000178262\n  [7 ,  1]  =  1.10427e-6\n  [8 ,  1]  =  6.12673e-11\n  [1 ,  2]  =  0.11053\n  [2 ,  2]  =  0.411336\n  [3 ,  2]  =  0.543708\n  [4 ,  2]  =  0.422368\n  [5 ,  2]  =  0.234511\n  [6 ,  2]  =  0.111732\n  [7 ,  2]  =  0.0558643\n  [8 ,  2]  =  0.0351626\n  ⋮\n  [73, 15]  =  0.0351626\n  [74, 15]  =  0.0558643\n  [75, 15]  =  0.111732\n  [76, 15]  =  0.234511\n  [77, 15]  =  0.422368\n  [78, 15]  =  0.543708\n  [79, 15]  =  0.411336\n  [80, 15]  =  0.11053\n  [73, 16]  =  6.12673e-11\n  [74, 16]  =  1.10427e-6\n  [75, 16]  =  0.000178262\n  [76, 16]  =  0.00463197\n  [77, 16]  =  0.0429226\n  [78, 16]  =  0.196947\n  [79, 16]  =  0.525563\n  [80, 16]  =  0.886629\n\njulia> B.S\n16×16 BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:\n 0.00769231   0.00492814   0.00142795   0.000218646  1.79179e-5   7.31907e-7   …   ⋅            ⋅            ⋅            ⋅            ⋅\n 0.00492814   0.0110567    0.00855534   0.00328365   0.000674239  7.04773e-5       ⋅            ⋅            ⋅            ⋅            ⋅\n 0.00142795   0.00855534   0.0147851    0.0118803    0.00501486   0.00109218       ⋅            ⋅            ⋅            ⋅            ⋅\n 0.000218646  0.00328365   0.0118803    0.0187451    0.015232     0.00647614       ⋅            ⋅            ⋅            ⋅            ⋅\n 1.79179e-5   0.000674239  0.00501486   0.015232     0.0232999    0.0188319        ⋅            ⋅            ⋅            ⋅            ⋅\n 7.31907e-7   7.04773e-5   0.00109218   0.00647614   0.0188319    0.0289487    …  1.92709e-11   ⋅            ⋅            ⋅            ⋅\n 1.15625e-8   2.93435e-6   0.000100846  0.00126285   0.0074747    0.0228901       1.57581e-7   3.01107e-11   ⋅            ⋅            ⋅\n  ⋅           3.61328e-10  5.83108e-7   4.39448e-5   0.000854471  0.00665362      2.83876e-5   2.46171e-7   7.13735e-11   ⋅            ⋅\n  ⋅            ⋅           7.13735e-11  2.46171e-7   2.83876e-5   0.000726484     0.000854471  4.39448e-5   5.83108e-7   3.61328e-10   ⋅\n  ⋅            ⋅            ⋅           3.01107e-11  1.57581e-7   2.37367e-5      0.0074747    0.00126285   0.000100846  2.93435e-6   1.15625e-8\n  ⋅            ⋅            ⋅            ⋅           1.92709e-11  1.31324e-7   …  0.0188319    0.00647614   0.00109218   7.04773e-5   7.31907e-7\n  ⋅            ⋅            ⋅            ⋅            ⋅           1.92709e-11     0.0232999    0.015232     0.00501486   0.000674239  1.79179e-5\n  ⋅            ⋅            ⋅            ⋅            ⋅            ⋅              0.015232     0.0187451    0.0118803    0.00328365   0.000218646\n  ⋅            ⋅            ⋅            ⋅            ⋅            ⋅              0.00501486   0.0118803    0.0147851    0.00855534   0.00142795\n  ⋅            ⋅            ⋅            ⋅            ⋅            ⋅              0.000674239  0.00328365   0.00855534   0.0110567    0.00492814\n  ⋅            ⋅            ⋅            ⋅            ⋅            ⋅           …  1.79179e-5   0.000218646  0.00142795   0.00492814   0.00769231","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"If we thus have to vectors of expansion coefficients, we can calculate the inner product of the correspond splines very simply:","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"julia> c = B \\ x -> sin(2π*x)\n16-element Array{Float64,1}:\n  1.5675074227379815e-7\n  0.10471902453028906\n  0.3141611768331591\n  0.6159137789819404\n  0.9438219608666177\n  1.1224640274531983\n  0.9080930336327867\n  0.34686036375515594\n -0.3468603637551552\n -0.9080930336327886\n -1.1224640274531954\n -0.9438219608666232\n -0.6159137789819348\n -0.3141611768331642\n -0.10471902453028659\n -1.567507426314564e-7\n\njulia> c̃ = B \\ x -> cos(2π*x)\n16-element Array{Float64,1}:\n  1.0000000051659867\n  1.0000000496779038\n  0.9736805198549477\n  0.8552480183377358\n  0.5498061181490912\n  3.468447866195647e-7\n -0.6597681895565798\n -1.0675270371816847\n -1.0675270371816876\n -0.6597681895565795\n  3.4684478615396205e-7\n  0.5498061181490913\n  0.855248018337735\n  0.9736805198549482\n  1.0000000496779042\n  1.0000000051659863\n\njulia> c'*B.S*c̃\n1-element Array{Float64,1}:\n 9.71445146547012e-17","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"[orthogonal, as expected, since int_0^1diffxsin(2pi x)cos(2pi x)=0]. However, instead of manually supplying the overlap matrix matS, it is more convenient to first construct the splines and then compute the inner product:","category":"page"},{"location":"bsplines/inner_products/#","page":"Inner products and norms","title":"Inner products and norms","text":"julia> s = B*c\nSpline on BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (10 intervals)\n\njulia> s̃ = B*c̃\nSpline on BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (10 intervals)\n\njulia> s's̃\nContinuumArrays.QuasiArrays.ApplyQuasiArray{Float64,1,LazyArrays.Applied{ContinuumArrays.QuasiArrays.LazyQuasiArrayApplyStyle,typeof(*),Tuple{Adjoint{Float64,Array{Float64,1}},ContinuumArrays.QuasiArrays.QuasiAdjoint{Float64,BSpline{Float64,Float64,LinearKnotSet{7,7,7,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},Array{Float64,1},Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64},BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}}},BSpline{Float64,Float64,LinearKnotSet{7,7,7,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},Array{Float64,1},Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64},BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}},Array{Float64,1}}}}([1.56751e-7 0.104719 … -0.104719 -1.56751e-7]⋆ContinuumArrays.QuasiArrays.QuasiAdjoint{Float64,BSpline{Float64,Float64,LinearKnotSet{7,7,7,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},Array{Float64,1},Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64},BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}}}(BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (10 intervals))⋆BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..1.0 (10 intervals)⋆[1.0, 1.0, 0.973681, 0.855248, 0.549806, 3.46845e-7, -0.659768, -1.06753, -1.06753, -0.659768, 3.46845e-7, 0.549806, 0.855248, 0.973681, 1.0, 1.0])","category":"page"},{"location":"bsplines/eigenproblems/#Eigenproblems-1","page":"Eigenproblems","title":"Eigenproblems","text":"","category":"section"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"Since the B-spline basis is non-orthogonal, eigenproblems become generalized when projecting the operators onto the space spaceP_tk, as mentioned in Solving equations. ArnoldiMethod.jl is primarily designed to solve standard eigenproblems of the form matAvecx = lambda vecx, and furthermore, as all Krylov methods, it is best at finding the eigenvalues which have the largest magnitude. To solve generalized eigenproblems on the form matAvecx = lambda matBvecx, and additionally looking for an interior eigenvalue, we can employ the shift-and-invert trick mentioned in the ArnoldiMethod.jl manual, reiterated here:","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"Instead of iterating matAvecV_i on various test vectors vecV_i, we iterate the shifted and inverted matrix matB^-1(matA-sigmamatB)^-1vecV_i=(matA-sigmamatB)^-1matBvecV_i, where sigma is a shift in whose vicinity we hope to find the true eigenvalue.","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"This can be accomplished with the aid of this struct:","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"struct ShiftAndInvert{TA,TB,TT}\n    A⁻¹::TA\n    B::TB\n    temp::TT\nend\n\nBase.size(S::ShiftAndInvert, args...) = size(S.A⁻¹, args...)\nBase.eltype(S::ShiftAndInvert) = eltype(S.A⁻¹)\n\nfunction LinearAlgebra.mul!(y,M::ShiftAndInvert,x)\n    mul!(M.temp, M.B, x)\n    ldiv!(y, M.A⁻¹, M.temp)\nend\n\nconstruct_linear_map(A,B,σ=0) =\n    ShiftAndInvert(factorize(A-σ*B),B,Vector{eltype(A)}(undef, size(A,1)))","category":"page"},{"location":"bsplines/eigenproblems/#Non-relativistic-hydrogen-(Schrödinger-equation)-1","page":"Eigenproblems","title":"Non-relativistic hydrogen (Schrödinger equation)","text":"","category":"section"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"The eigenstates of non-relativistic hydrogen obey the following time-independent Schrödinger equation (in atomic units):","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"beginequation\nHamiltonianketPsi = EketPsi\nendequation","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"where the Hamiltonian is given by","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"beginequation\nHamiltonian = operatorT + operatorV = -fracnabla^22 - frac1r\nendequation","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"By going over to spherical coordinates","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"beginequation\nPsi(vecr)=\nsum_nell m\nR_nell(r)Y^ell_m(Omega)\nendequation","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"and employing reduced wavefuntions","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"beginequation\nP_nell(r)defd rR_nell(r)\nendequation","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"we can rewrite the radial equation as","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"beginequation\nHamiltonian P_nell(r) =\nleft-fracpartial_r^22 + fracell(ell+1)2r^2 - frac1rright\nP_nell(r) = E_nellP_nell(r)\nendequation","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"This equation can be solved with B-splines (and exactly).","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"We will yet again (as in Diagonal operators) illustrate the effect of different knot sets on the solution. Again, we use the following two basis sets:","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"julia> k = 7\n7\n\njulia> N = 31\n31\n\njulia> a,b = 0,70\n(0, 70)\n\njulia> coulomb(r) = -1/r\ncoulomb (generic function with 1 method)\n\njulia> tlin = LinearKnotSet(k, a, b, N);\n\njulia> texp = ExpKnotSet(k, -1.0, log10(b), N);\n\njulia> Blin = BSpline(tlin,3)[:,2:end-1]\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..70.0 (31 intervals), restricted to basis functions 2..36 ⊂ 1..37\n\njulia> Bexp = BSpline(texp,3)[:,2:end-1]\nBSpline{Float64} basis with ExpKnotSet(Float64) of  on order k = 7 on 0,0.1..70.00000000000001 (31 intervals), restricted to basis functions 2..36 ⊂ 1..37","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"Then, for B=Blin and B=Bexp, we do (considering only ell=0):","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"nev = 5\nσ = -0.5 # Target eigenvalue\n\nS = B'B\n\nD = Derivative(axes(B, 1))\n∇² = B'D'D*B\nT = -∇²/2\n\nV = Matrix(coulomb, B)\n\nH = T + V\n\nschurQR,history = partialschur(construct_linear_map(H, S, σ), nev=nev)\n\nθ = schurQR.eigenvalues\nE = real(σ .+ inv.(θ))","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"The exact eigenenergies for hydrogen are given by (independent of ell due to the accidental Coulomb degeneracy):","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"beginequation\nE_nell = -frac12n^2\nendequation","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"Especially the ground state wavefunction is vastly improved by the exponential knot set:","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"n E_n exact E_n linear delta E_n linear E_n exponential delta E_n exponential\n1 -0.50000 -0.50000 4.09551e-06 -0.50000 5.82062e-12\n2 -0.12500 -0.12500 1.33518e-07 -0.12500 -2.68710e-07\n3 -0.05556 -0.05556 1.68308e-08 -0.05556 2.61414e-07\n4 -0.03125 -0.03125 5.77127e-08 -0.03125 8.72813e-08\n5 -0.02000 -0.01994 5.60046e-05 -0.01994 5.63700e-05","category":"page"},{"location":"bsplines/eigenproblems/#","page":"Eigenproblems","title":"Eigenproblems","text":"(Image: Hydrogen eigenstates)","category":"page"},{"location":"overview/#Overview-1","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Evaluating-basis-functions-1","page":"Overview","title":"Evaluating basis functions","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"We can evaluate one or more basis functions at a single point or over a range of values:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"julia> B = FiniteDifferences(10, 0.1)\nFinite differences basis {Float64} on 0.0..1.1 with 10 points spaced by Δx = 0.1\n\njulia> B[0.15,1]\n0.5000000000000001\n\njulia> B[0.15,1:3]\n3-element Array{Float64,1}:\n 0.5000000000000001\n 0.4999999999999999\n 0.0\n\njulia> B[0.0:0.05:1.1,:]\n23×10 SparseArrays.SparseMatrixCSC{Float64,Int64} with 30 stored entries:\n  [2 ,  1]  =  0.5\n  [3 ,  1]  =  1.0\n  [4 ,  1]  =  0.5\n  [4 ,  2]  =  0.5\n  [5 ,  2]  =  1.0\n  [6 ,  2]  =  0.5\n  [6 ,  3]  =  0.5\n  [7 ,  3]  =  1.0\n  [8 ,  3]  =  0.5\n  [8 ,  4]  =  0.5\n  [9 ,  4]  =  1.0\n  [10,  4]  =  0.5\n  [10,  5]  =  0.5\n  [11,  5]  =  1.0\n  [12,  5]  =  0.5\n  [12,  6]  =  0.5\n  [13,  6]  =  1.0\n  [14,  6]  =  0.5\n  [14,  7]  =  0.5\n  [15,  7]  =  1.0\n  [16,  7]  =  0.5\n  [16,  8]  =  0.5\n  [17,  8]  =  1.0\n  [18,  8]  =  0.5\n  [18,  9]  =  0.5\n  [19,  9]  =  1.0\n  [20,  9]  =  0.5\n  [20, 10]  =  0.5\n  [21, 10]  =  1.0\n  [22, 10]  =  0.5","category":"page"},{"location":"overview/#(Non-)Orthogonal-bases-1","page":"Overview","title":"(Non-)Orthogonal bases","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"By orthogonal basis we mean those that have metrics[metric] with one diagonal only. The values on the diagonal can be different from unity (i.e. it may be an integration weight):","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"julia> B = FiniteDifferences(10, 0.1)\nFinite differences basis {Float64} on 0.0..1.1 with 10 points spaced by Δx = 0.1\n\njulia> S = B'B\n10×10 Diagonal{Float64,Fill{Float64,1,Tuple{Base.OneTo{Int64}}}}:\n 0.1   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅   0.1   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅   0.1   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅   0.1   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅   0.1   ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅   0.1   ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   0.1   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   0.1   ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   0.1   ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   0.1","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In contrast, a non-orthogonal basis such as B-splines has a banded metric:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"julia> t = LinearKnotSet(5, 0, 1.0, 5)\n14-element LinearKnotSet{5,5,5,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.2\n 0.4\n 0.6\n 0.8\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> B = BSpline(t)\nBSpline{Float64} basis with LinearKnotSet(Float64) of order k = 5 (quartic) on 0.0..1.0 (5 intervals)\n\njulia> S = B'B\n9×9 BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:\n 0.0222222    0.0139286    0.00347002  0.000365961  1.32275e-5    ⋅            ⋅           ⋅            ⋅\n 0.0139286    0.0331746    0.0246054   0.00747795   0.000811839  1.65344e-6    ⋅           ⋅            ⋅\n 0.00347002   0.0246054    0.0464947   0.0349662    0.0100953    0.00036737   9.79816e-7   ⋅            ⋅\n 0.000365961  0.00747795   0.0349662   0.0629159    0.0460378    0.00786712   0.00036737  1.65344e-6    ⋅\n 1.32275e-5   0.000811839  0.0100953   0.0460378    0.0860836    0.0460378    0.0100953   0.000811839  1.32275e-5\n  ⋅           1.65344e-6   0.00036737  0.00786712   0.0460378    0.0629159    0.0349662   0.00747795   0.000365961\n  ⋅            ⋅           9.79816e-7  0.00036737   0.0100953    0.0349662    0.0464947   0.0246054    0.00347002\n  ⋅            ⋅            ⋅          1.65344e-6   0.000811839  0.00747795   0.0246054   0.0331746    0.0139286\n  ⋅            ⋅            ⋅           ⋅           1.32275e-5   0.000365961  0.00347002  0.0139286    0.0222222","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"where the bandwidth depends on the B-spline order.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"For a review on non-orthogonal basis sets, and the complications they introduce, see e.g.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Soriano, M., & Palacios, J. J. (2014). Theory of Projections with Nonorthogonal Basis Sets: Partitioning Techniques and Effective Hamiltonians. Physical Review B, 90(7), 075128. DOI: 10.1103/physrevb.90.075128, arXiv: 1404.2043","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"[metric]: also known as mass matrix, Gramian matrix, overlap matrix, etc.","category":"page"},{"location":"overview/#Restricted-bases-1","page":"Overview","title":"Restricted bases","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Restricted bases are those where a subset of the basis functions have been selected:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"julia> B = FEDVR(range(0, stop=10.0, length=5), 7)\nFEDVR{Float64} basis with 4 elements on 0.0..10.0\n\njulia> B̃ = B[:, 3:17]\nFEDVR{Float64} basis with 4 elements on 0.0..10.0, restricted to elements 1:3, basis functions 3..17 ⊂ 1..25","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"(Image: Restricted bases)","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"It is common to drop the first and last elements to impose Dirichlet0 boundary conditions, but one could think of other examples, such as splitting the computation into overlapping chunks, etc.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The metric between differently restricted orthogonal bases is a BandedMatrix where the sole diagonal is offset:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"julia> S = B'B̃\n25×15 BandedMatrices.BandedMatrix{Float64,FillArrays.Fill{Float64,2,Tuple{Base.OneTo{Int64},Base.OneTo{Int64}}},Base.OneTo{Int64}}:\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅","category":"page"},{"location":"#CompactBases.jl-1","page":"Home","title":"CompactBases.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CompactBases.jl is a package for various bases for function approximation with compact support in the framework of ContinuumArrays","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: CompactBases logo)","category":"page"},{"location":"#Example-usage-1","page":"Home","title":"Example usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> a,b = 0.0,1.0 # Extents\n(0.0, 1.0)\n\njulia> N = 13 # Number of nodes\n13\n\njulia> k = 5 # Order of B-splines\n5\n\njulia> x = range(a, stop=b, length=1000)\n0.0:0.001001001001001001:1.0\n\njulia> Δx = (b-a)/(N+1) # Grid spacing\n0.07142857142857142\n\njulia> # Standard, uniform finite-differences\n           fd = FiniteDifferences(N, Δx)\nFinite differences basis {Float64} on 0.0..1.0 with 13 points spaced by Δx = 0.07142857142857142\n\njulia> # Staggered, uniform finite-differences\n           sfd_uni = StaggeredFiniteDifferences(N, Δx)\nStaggered finite differences basis {Float64} on 0.0..0.9642857142857144 with 13 points spaced by ρ = 0.07142857142857142\n\njulia> # Staggered, non-uniform finite-differences\n           sfd_nonuni = StaggeredFiniteDifferences(0.01, 0.5, 0.1, b)\nStaggered finite differences basis {Float64} on 0.0..1.1112312795594823 with 39 points\n\njulia> # Finite-element boundaries\n           tf = range(a, stop=b, length=N+2)\n0.0:0.07142857142857142:1.0\n\njulia> using LazyArrays, FillArrays\n\njulia> # We can vary the polynomial order in each element\n           forder = Vcat(7, Fill(4,length(tf)-2))\n14-element ApplyArray{Int64,1,typeof(vcat),Tuple{Int64,Fill{Int64,1,Tuple{Base.OneTo{Int64}}}}}:\n 7\n 4\n 4\n 4\n 4\n 4\n 4\n 4\n 4\n 4\n 4\n 4\n 4\n 4\n\njulia> # By indexing the second dimension, we can implement Dirichlet0\n           # boundary conditions.\n           fem = FEDVR(tf, forder)[:,2:end-1]\nFEDVR{Float64} basis with 14 elements on 0.0..1.0, restricted to elements 1:14, basis functions 2..45 ⊂ 1..46\n\njulia> tb = ExpKnotSet(k, -2.0, log10(b), N+1)\n23-element ExpKnotSet{5,5,5,Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Array{Float64,1}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.01\n 0.014251026703029978\n 0.020309176209047358\n 0.028942661247167503\n 0.04124626382901352\n 0.05878016072274912\n 0.0837677640068292\n 0.11937766417144363\n 0.17012542798525887\n 0.24244620170823283\n 0.3455107294592219\n 0.4923882631706739\n 0.7017038286703828\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> splines = BSpline(tb)[:,2:end-1]\nBSpline{Float64} basis with ExpKnotSet(Float64) of  on order k = 5 (quartic) on 0,0.01..1.0 (14 intervals), restricted to basis functions 2..17 ⊂ 1..18","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Simple example)","category":"page"},{"location":"#Reference-1","page":"Home","title":"Reference","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [CompactBases]","category":"page"},{"location":"#CompactBases.StaggeredFiniteDifferences","page":"Home","title":"CompactBases.StaggeredFiniteDifferences","text":"StaggeredFiniteDifferences\n\nStaggered finite differences with variationally derived three-points stencils for the case where there is Dirichlet0 boundary condition at r = 0. Supports non-uniform grids, c.f.\n\nKrause, J. L., & Schafer, K. J. (1999). Control of THz Emission from Stark Wave Packets. The Journal of Physical Chemistry A, 103(49), 10118–10125. http://dx.doi.org/10.1021/jp992144\n\n\n\n\n\n","category":"type"},{"location":"#CompactBases.centers-Tuple{Union{B, #s13} where #s13<:(QuasiArrays.SubQuasiArray{#s12,#s14,#s15,I,L} where L where I where #s15<:B where #s14 where #s12) where B<:ContinuumArrays.Basis}","page":"Home","title":"CompactBases.centers","text":"centers(B)\n\nReturn the locations of the mass centers of all basis functions of B; for orthogonal bases such as finite-differences and FE-DVR, this is simply locs, i.e. the location of the quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.nonempty_intervals-Tuple{CompactBases.AbstractKnotSet}","page":"Home","title":"CompactBases.nonempty_intervals","text":"nonempty_intervals(t)\n\nReturn the indices of all intervals of the knot set t that are non-empty.\n\nExamples\n\njulia> nonempty_intervals(ArbitraryKnotSet(3, [0.0, 1, 1, 3, 4, 6], 1, 3))\n4-element Array{Int64,1}:\n 1\n 3\n 4\n 5\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.numfunctions-Tuple{CompactBases.AbstractKnotSet}","page":"Home","title":"CompactBases.numfunctions","text":"numfunctions(t)\n\nReturns the number of basis functions generated by knot set t.\n\nExamples\n\njulia> numfunctions(LinearKnotSet(3, 0, 1, 2))\n4\n\njulia> numfunctions(LinearKnotSet(5, 0, 1, 2))\n6\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.numintervals-Tuple{CompactBases.AbstractKnotSet}","page":"Home","title":"CompactBases.numintervals","text":"numinterval(t)\n\nReturns the number of intervals generated by the knot set t.\n\nExamples\n\njulia> numintervals(LinearKnotSet(3, 0, 1, 2))\n2\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.order-Union{Tuple{CompactBases.AbstractKnotSet{k,ml,mr,T} where T where mr where ml}, Tuple{k}} where k","page":"Home","title":"CompactBases.order","text":"order(t)\n\nReturns the order k of the knot set t.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.UnitVector","page":"Home","title":"CompactBases.UnitVector","text":"UnitVector{T}(N, k)\n\nHelper vector type of length N where the kth element is one(T) and all the others zero(T).\n\n\n\n\n\n","category":"type"},{"location":"#Base.first-Tuple{CompactBases.AbstractKnotSet}","page":"Home","title":"Base.first","text":"first(t)\n\nReturn the first knot of t.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{mr}, Tuple{ml}, Tuple{k}, Tuple{CompactBases.AbstractKnotSet{k,ml,mr,T} where T,Integer}} where mr where ml where k","page":"Home","title":"Base.getindex","text":"getindex(t, i)\n\nReturn the ith knot of the knot set t, accounting for the multiplicities of the endpoints.\n\nExamples\n\njulia> LinearKnotSet(3, 0, 1, 3)[2]\n0.0\n\njulia> LinearKnotSet(3, 0, 1, 3, 1, 1)[2]\n0.3333333333333333\n\n\n\n\n\n","category":"method"},{"location":"#Base.last-Tuple{CompactBases.AbstractKnotSet}","page":"Home","title":"Base.last","text":"last(t)\n\nReturn the last knot of t.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{CompactBases.AbstractKnotSet}","page":"Home","title":"Base.length","text":"length(t)\n\nReturn the number of knots of t.\n\nExamples\n\njulia> length(LinearKnotSet(3, 0, 1, 3))\n8\n\njulia> length(LinearKnotSet(3, 0, 1, 3, 1, 1))\n4\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.assert_multiplicities-NTuple{4,Any}","page":"Home","title":"CompactBases.assert_multiplicities","text":"assert_multiplicities(k,ml,mr,t)\n\nAssert that the multiplicities at the endpoints, ml and mr, respectively, are consistent with the order k. Also check that the amount of knots in the knot set t are enough to support the requested order k.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.change_interval!-Union{Tuple{T}, Tuple{AbstractArray{T,1},Any,Any,Any}, Tuple{AbstractArray{T,1},Any,Any,Any,Any}, Tuple{AbstractArray{T,1},Any,Any,Any,Any,Any}, Tuple{AbstractArray{T,1},Any,Any,Any,Any,Any,Any}} where T","page":"Home","title":"CompactBases.change_interval!","text":"change_interval!(xs, ws, x, w[, a=0, b=1, γ=1])\n\nTransform the Gaußian quadrature roots x and weights w on the elementary interval [-1,1] to the interval [γ*a,γ*b] and store the result in xs and ws, respectively. γ is an optional root of unity, used to complex-rotate the roots (but not the weights).\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.deBoor-Union{Tuple{T}, Tuple{CompactBases.AbstractKnotSet,AbstractArray{T,1},Any}, Tuple{CompactBases.AbstractKnotSet,AbstractArray{T,1},Any,Any}, Tuple{CompactBases.AbstractKnotSet,AbstractArray{T,1},Any,Any,Any}} where T","page":"Home","title":"CompactBases.deBoor","text":"deBoor(t, c, x[, i[, m=0]])\n\nEvaluate the spline given by the knot set t and the set of control points c at x using de Boor's algorithm. i is the index of the knot interval containing x. If m≠0, calculate the mth derivative at x instead.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.find_interval-Union{Tuple{mr}, Tuple{ml}, Tuple{k}, Tuple{T}, Tuple{CompactBases.AbstractKnotSet{k,ml,mr,T},Any}, Tuple{CompactBases.AbstractKnotSet{k,ml,mr,T},Any,Any}} where mr where ml where k where T","page":"Home","title":"CompactBases.find_interval","text":"find_interval(t, x[, i=ml])\n\nFind the interval in the knot set t that includes x, starting from interval i (which by default is the first non-zero interval of the knot set). The search complexity is linear, but by storing the result and using it as starting point for the next call to find_interval, the knot set need only be traversed once.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.findelement","page":"Home","title":"CompactBases.findelement","text":"findelement(B::FEDVR, k[, i=1, m=k])\n\nFind the finite-element of B that contains the kth basis function, optionally starting the search from element i and basis function m of that element.\n\n\n\n\n\n","category":"function"},{"location":"#CompactBases.lagrangeder!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T}","page":"Home","title":"CompactBases.lagrangeder!","text":"lagrangeder!(xⁱ, m, L′)\n\nCalculate the derivative of the Lagrange interpolating polynomial Lⁱₘ(x), given the roots xⁱ, at the roots, and storing the result in L′.\n\n∂ₓ Lⁱₘ(xⁱₘ,) = (xⁱₘ-xⁱₘ,)⁻¹ ∏(k≠m,m′) (xⁱₘ,-xⁱₖ)/(xⁱₘ-xⁱₖ), m≠m′,                 [δ(m,n) - δ(m,1)]/2wⁱₘ,                    m=m′\n\nEq. (20) Rescigno2000\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.leftmultiplicity-Union{Tuple{CompactBases.AbstractKnotSet{k,ml,mr,T} where T}, Tuple{mr}, Tuple{ml}, Tuple{k}} where mr where ml where k","page":"Home","title":"CompactBases.leftmultiplicity","text":"leftmultiplicity(t)\n\nReturn the multiplicity of the left endpoint.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.lgwt-Union{Tuple{T}, Tuple{mr}, Tuple{ml}, Tuple{k}, Tuple{CompactBases.AbstractKnotSet{k,ml,mr,T},Any}} where T where mr where ml where k","page":"Home","title":"CompactBases.lgwt","text":"lgwt(t, N) -> (x,w)\n\nGenerate the N Gauß–Legendre quadrature roots x and associated weights w, with respect to the B-spline basis generated by the knot set t.\n\nExamples\n\njulia> CompactBases.lgwt(LinearKnotSet(2, 0, 1, 3), 2)\n([0.0704416, 0.262892, 0.403775, 0.596225, 0.737108, 0.929558], [0.166667, 0.166667, 0.166667, 0.166667, 0.166667, 0.166667])\n\njulia> CompactBases.lgwt(ExpKnotSet(2, -4, 2, 7), 2)\n([2.11325e-5, 7.88675e-5, 0.000290192, 0.000809808, 0.00290192, 0.00809808, 0.0290192, 0.0809808, 0.290192, 0.809808, 2.90192, 8.09808, 29.0192, 80.9808], [5.0e-5, 5.0e-5, 0.00045, 0.00045, 0.0045, 0.0045, 0.045, 0.045, 0.45, 0.45, 4.5, 4.5, 45.0, 45.0])\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.local_step-Tuple{AbstractFiniteDifferences,Any}","page":"Home","title":"CompactBases.local_step","text":"local_step(B, i)\n\nThe step size around grid point i. For uniform grids, this is equivalent to step.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.num_quadrature_points-Tuple{Any,Any}","page":"Home","title":"CompactBases.num_quadrature_points","text":"num_quadrature_points(k, k′)\n\nThe number of quadrature points needed to exactly compute the matrix elements of an operator of polynomial order k′ with respect to a basis of order k.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.rightmultiplicity-Union{Tuple{CompactBases.AbstractKnotSet{k,ml,mr,T} where T}, Tuple{mr}, Tuple{ml}, Tuple{k}} where mr where ml where k","page":"Home","title":"CompactBases.rightmultiplicity","text":"rightmultiplicity(t)\n\nReturn the multiplicity of the right endpoint.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.within_interval-Tuple{AbstractRange,Interval}","page":"Home","title":"CompactBases.within_interval","text":"within_interval(x, interval)\n\nReturn the indices of the elements of x that lie within the given interval.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.within_support-Tuple{AbstractArray{T,1} where T,CompactBases.AbstractKnotSet,Integer}","page":"Home","title":"CompactBases.within_support","text":"within_support(x, t, j)\n\nReturn the indices of the elements of x that lie withing the compact support of the jth basis function (enumerated 1..n), given the knot set t. For each index of x that is covered, the index k of the interval within which x[i] falls is also returned.\n\n\n\n\n\n","category":"method"},{"location":"#CompactBases.@materialize-Tuple{Any}","page":"Home","title":"CompactBases.@materialize","text":"@materialize function op(args...)\n\nThis macro simplifies the setup of a few functions necessary for the materialization of Applied objects:\n\nApplyStyle, used to ensure dispatch of the applied object to the routines below\ncopyto!(dest::DestType, applied_obj::Applied{...,op}) performs the actual materialization of applied_obj into the destination object which has been generated by\nsimilar which usually returns a suitable matrix\nmaterialize which makes use of the above functions\n\nExample\n\n@materialize function *(Ac::MyAdjointBasis,\n                        O::MyOperator,\n                        B::MyBasis)\n    MyApplyStyle # An instance of this type will be returned by ApplyStyle\n    T -> begin # generates similar\n        A = parent(Ac)\n        parent(A) == parent(B) ||\n            throw(ArgumentError(\"Incompatible bases\"))\n\n        # There may be different matrices best representing different\n        # situations:\n        if ...\n            Diagonal(Vector{T}(undef, size(B,1)))\n        else\n            Tridiagonal(Vector{T}(undef, size(B,1)-1),\n                        Vector{T}(undef, size(B,1)),\n                        Vector{T}(undef, size(B,1)-1))\n        end\n    end\n    dest::Diagonal{T} -> begin # generate copyto!(dest::Diagonal{T}, ...) where T\n        dest.diag .= 1\n    end\n    dest::Tridiagonal{T} -> begin # generate copyto!(dest::Tridiagonal{T}, ...) where T\n        dest.dl .= -2\n        dest.ev .= 1\n        dest.du .= 3\n    end\nend\n\n\n\n\n\n","category":"macro"}]
}
