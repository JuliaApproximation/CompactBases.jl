<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Densities · CompactBases.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../assets/latex.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="CompactBases.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">CompactBases.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../inner_products/">Inner products &amp; norms</a></li><li><span class="tocitem">Operators</span><ul><li><a class="tocitem" href="../diagonal_operators/">Diagonal operators</a></li></ul></li><li class="is-active"><a class="tocitem" href>Densities</a><ul class="internal"><li><a class="tocitem" href="#Example-1"><span>Example</span></a></li><li><a class="tocitem" href="#Reference-1"><span>Reference</span></a></li><li><a class="tocitem" href="#Bibliography-1"><span>Bibliography</span></a></li></ul></li><li><span class="tocitem">Finite-differences</span><ul><li><a class="tocitem" href="../fd_overview/">Overview</a></li><li><a class="tocitem" href="../fd_non_uniform/">Non-uniform grids</a></li></ul></li><li><span class="tocitem">B-splines</span><ul><li><a class="tocitem" href="../bsplines/theory/">Theory</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Usage</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../bsplines/usage/">Basis creation</a></li><li><a class="tocitem" href="../bsplines/knot_sets/">Knot sets</a></li><li><input class="collapse-toggle" id="menuitem-7-2-3" type="checkbox"/><label class="tocitem" for="menuitem-7-2-3"><span class="docs-label">Splines</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../bsplines/splines/">Spline creation &amp; evaluation</a></li><li><a class="tocitem" href="../bsplines/function_approximation/">Function approximation</a></li></ul></li><li><a class="tocitem" href="../bsplines/operators/">Approximating operators</a></li><li><input class="collapse-toggle" id="menuitem-7-2-5" type="checkbox"/><label class="tocitem" for="menuitem-7-2-5"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../bsplines/differentiation/">Differentiating functions</a></li><li><a class="tocitem" href="../bsplines/odes/">Ordinary differential equations</a></li><li><a class="tocitem" href="../bsplines/eigenproblems/">Eigenproblems</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Densities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Densities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaApproximation/CompactBases.jl/blob/master/docs/src/densities.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Densities-1"><a class="docs-heading-anchor" href="#Densities-1">Densities</a><a class="docs-heading-anchor-permalink" href="#Densities-1" title="Permalink"></a></h1><p>The <em>mutual density</em> between two functions <span>$f(x)$</span> and <span>$g(x)$</span> is defined as</p><div>\[(f\cdot g)(x) \defd \conj{f}(x)g(x)\]</div><p>where the term density is used in analogy with <a href="https://en.wikipedia.org/wiki/Density_matrix">density matrices in quantum mechanics</a>, and for which reason the first function is conjugated. Without the conjugate, it is equivalent to the <a href="https://en.wikipedia.org/wiki/Pointwise_product">pointwise product</a>.</p><p>The mutual density <span>$h(x)$</span> of two functions expanded over two sets of basis functions</p><div>\[\begin{aligned}
f(x) &amp;= \sum_i f_i \ket{A_i}, &amp;
g(x) &amp;= \sum_i g_i \ket{B_i},
\end{aligned}\]</div><p>can be expressed as one expansion over one set of basis functions,</p><div>\[h(x) = \sum_i h_i \ket{C_i},\]</div><p>and this can be computed using <a href="#CompactBases.Density"><code>Density</code></a>, as long as <span>$\ket{A_i}$</span> and <span>$\ket{B_i}$</span> are compatible. The space spanned by <span>$\ket{C_i}$</span> must be able to express products of the original spaces, i.e. if <span>$f(x)$</span> and <span>$g(x)$</span> are both quadratic functions, formally <span>$h(x)$</span> will be a quartic function. There exist rather complicated algorithms for producing the expansion coefficients for the product function expanded over B-splines of higher order than the constituent     factors (see e.g. <sup class="footnote-reference"><a id="citeref-moerken1991" href="#footnote-moerken1991">[moerken1991]</a></sup>), however this is rarely needed in practice since we either </p><ol><li>use enough intervals to successfully approximate the function as piecewise polynomials of lower order,</li><li>use high enough polynomial order of our basis functions that we can represent the factors and their product satisfactorily,</li><li>or both of the above.</li></ol><p>Therefore, we instead turn to the pragmatic approach which is based on the <a href="https://en.wikipedia.org/wiki/Vandermonde_matrix">Vandermonde matrix</a>: if we want to find the expansion coefficients of <span>$h(x)$</span> on the basis <span>$\ket{C_i}$</span>, we compute the Vandermonde matrix <span>$\mat{V}_C$</span> (using <a href="@ref"><code>vandermonde</code></a>) for that basis and solve</p><div>\[\mat{V}_C \vec{h} = h(\vec{x})\]</div><p>where the right-hand side <span>$h(\vec{x})$</span> denotes the function values of <span>$h(x)$</span> on all the interpolation points (returned by <a href="@ref"><code>locs</code></a>), but these are in turn given by <span>$(f\cdot g)(\vec{x})$</span>, which we can reconstruct from the expansion coefficients of <span>$f(x)$</span> and <span>$g(x)$</span> by multiplying those by <em>their</em> respective Vandermonde matrices <span>$\mat{V}_A$</span> and <span>$\mat{V}_B$</span>. In total, the expansion coefficients for the product function are thus given by</p><div>\[\vec{h} =
\mat{V}_C^+
[\mat{V}_A
\conj{\vec{f}}
\odot
\mat{V}_B
\vec{g}]\]</div><p>where <span>$\mat{V}_C^+$</span> is the Moore–Penrose inverse of <span>$\mat{V}_C$</span> which can easily be <a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Singular_value_decomposition_(SVD)">computed using its singular-value decomposition</a>, and <span>$\odot$</span> denotes the <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">elementwise or Hadamard product</a>, i.e. Julia&#39;s <code>.*</code> product. For this to work, naturally the bases <span>$\ket{A_i}$</span>, <span>$\ket{B_i}$</span>, and <span>$\ket{C_i}$</span> must share interpolation points <span>$\vec{x}$</span> and thus their Vandermonde matrices must have the same number of rows. For simplicity, CompactBases.jl assumes that <span>$\ket{B_i}$</span> and <span>$\ket{C_i}$</span> are the same and that <span>$\ket{A_i}$</span> is &quot;compatible&quot; (checked by <a href="@ref"><code>assert_compatible_bases</code></a>).</p><p>For orthogonal bases such as finite-difference and FE-DVR, where the Vandermonde matrix is diagonal and same for both bases, the above formula simplifies to</p><div>\[\vec{h} =
\mat{V}
[\conj{\vec{f}}
\odot
\vec{g}],\]</div><p>and in the case of finite-differences on a uniform grid, where the expansion coefficients coincide with the function values at the interpolation points, the Vandermonde matrix reduces to the identity matrix and the product formula is simpler still:</p><div>\[\vec{h} =
\conj{\vec{f}}
\odot
\vec{g}.\]</div><h2 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h2><pre><code class="language-julia-repl">julia&gt; import CompactBases: applied

julia&gt; f = x -&gt; sin(2π*x);

julia&gt; g = x -&gt; x*exp(-x);

julia&gt; h = x -&gt; f(x)*g(x);

julia&gt; rmax,k,N = 10.0,7,71
(10.0, 7, 71)

julia&gt; R = BSpline(LinearKnotSet(k, 0, rmax, N))
BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)

julia&gt; r = axes(R,1)
Inclusion(0.0..10.0)

julia&gt; cf = R \ f.(r);

julia&gt; cg = R \ g.(r);

julia&gt; ch = R \ h.(r); # Direct expansion of density for comparison

julia&gt; ρ = Density(applied(*,R,cf), applied(*,R,cg))
77 .* 77 -&gt; 77 FunctionProduct Float64, conjugated (&lt;=&gt; Density); L .* R -&gt; R, with
  L: BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)
  R: BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)

julia&gt; ρ.ρ # Expansion coefficients computed via Vandermonde interpolation
77-element Array{Float64,1}:
  2.5990302560741227e-6
 -1.2089008321819097e-5
  0.016650515757241868
  0.08609474140758361
  0.22264566607626868
  0.28428278922020694
  0.04487154524021238
 -0.3097583765428373
 -0.45136208173491543
 -0.23816476137564302
  0.16360184909444878
  0.43464800730290326
  0.3730492731330008
  0.046047307534972166
 -0.2846933885764034
 -0.3797631540817138
  ⋮
  0.002725515878867043
  0.0015277308449457526
 -0.00041784201453291337
 -0.0016586000070113436
 -0.0015285004379182573
 -0.00041624819494116155
  0.0007250143682327532
  0.0011338505005407673
  0.0007023771068706905
 -9.73144173106993e-5
 -0.0006544921666713287
 -0.0006548469749281168
 -0.0004243163194033977
 -0.00020768615644842965
 -6.69583797265351e-5
 -5.669216664398177e-10

julia&gt; norm(ρ.ρ - ch)
1.5656487551918337e-6</code></pre><p><img src="../figures/mutual_densities.svg" alt="Mutual densities"/></p><p>We can also compute the mutual densities between multiple functions, as long as their matrices of expansions coefficients are broadcastable:</p><pre><code class="language-julia-repl">julia&gt; ρ = Density(applied(*,R,cf), applied(*,R,[cg 2cg]))
77 .* (77, 2) -&gt; (77, 2) FunctionProduct Float64, conjugated (&lt;=&gt; Density); L .* R -&gt; R, with
  L: BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)
  R: BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)

julia&gt; ρ.ρ
77×2 Array{Float64,2}:
  2.59903e-6    5.19806e-6
 -1.2089e-5    -2.4178e-5
  0.0166505     0.033301
  0.0860947     0.172189
  0.222646      0.445291
  0.284283      0.568566
  0.0448715     0.0897431
 -0.309758     -0.619517
 -0.451362     -0.902724
 -0.238165     -0.47633
  0.163602      0.327204
  0.434648      0.869296
  0.373049      0.746099
  0.0460473     0.0920946
 -0.284693     -0.569387
 -0.379763     -0.759526
  ⋮
  0.00272552    0.00545103
  0.00152773    0.00305546
 -0.000417842  -0.000835684
 -0.0016586    -0.0033172
 -0.0015285    -0.003057
 -0.000416248  -0.000832496
  0.000725014   0.00145003
  0.00113385    0.0022677
  0.000702377   0.00140475
 -9.73144e-5   -0.000194629
 -0.000654492  -0.00130898
 -0.000654847  -0.00130969
 -0.000424316  -0.000848633
 -0.000207686  -0.000415372
 -6.69584e-5   -0.000133917
 -5.66922e-10  -1.13384e-9

julia&gt; ρ = Density(applied(*,R,[cf 2cf]), applied(*,R,[cg 2cg]))
(77, 2) .* (77, 2) -&gt; (77, 2) FunctionProduct Float64, conjugated (&lt;=&gt; Density); L .* R -&gt; R, with
  L: BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)
  R: BSpline{Float64} basis with LinearKnotSet(Float64) of order k = 7 on 0.0..10.0 (71 intervals)

julia&gt; ρ.ρ
77×2 Array{Float64,2}:
  2.59903e-6    1.03961e-5
 -1.2089e-5    -4.8356e-5
  0.0166505     0.0666021
  0.0860947     0.344379
  0.222646      0.890583
  0.284283      1.13713
  0.0448715     0.179486
 -0.309758     -1.23903
 -0.451362     -1.80545
 -0.238165     -0.952659
  0.163602      0.654407
  0.434648      1.73859
  0.373049      1.4922
  0.0460473     0.184189
 -0.284693     -1.13877
 -0.379763     -1.51905
  ⋮
  0.00272552    0.0109021
  0.00152773    0.00611092
 -0.000417842  -0.00167137
 -0.0016586    -0.0066344
 -0.0015285    -0.006114
 -0.000416248  -0.00166499
  0.000725014   0.00290006
  0.00113385    0.0045354
  0.000702377   0.00280951
 -9.73144e-5   -0.000389258
 -0.000654492  -0.00261797
 -0.000654847  -0.00261939
 -0.000424316  -0.00169727
 -0.000207686  -0.000830745
 -6.69584e-5   -0.000267834
 -5.66922e-10  -2.26769e-9</code></pre><h2 id="Reference-1"><a class="docs-heading-anchor" href="#Reference-1">Reference</a><a class="docs-heading-anchor-permalink" href="#Reference-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CompactBases.FunctionProduct" href="#CompactBases.FunctionProduct"><code>CompactBases.FunctionProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionProduct{Conjugated}</code></pre><p>Helper object to compute the expansion coefficients of <span>$ρ(x) \defd f^\circ(x)g(x)$</span>, where <span>$f^\circ$</span> denotes that <span>$f$</span> may be conjugated, if so desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/CompactBases.jl/blob/f18472803177f78645a4f30575071db5aa6cc270/src/densities.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CompactBases.Density" href="#CompactBases.Density"><code>CompactBases.Density</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Density</code></pre><p>Type-alias for <a href="#CompactBases.FunctionProduct"><code>FunctionProduct</code></a> where the first function is conjugated, as is necessary in complex linear algebra, when computing mutual densities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/CompactBases.jl/blob/f18472803177f78645a4f30575071db5aa6cc270/src/densities.jl#LL23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CompactBases.FunctionProduct-Union{Tuple{T}, Tuple{Conjugated}, Tuple{Union{B, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(QuasiArrays.SubQuasiArray{var&quot;#s13&quot;,var&quot;#s17&quot;,var&quot;#s18&quot;,I,L} where L where I where var&quot;#s18&quot;&lt;:B where var&quot;#s17&quot; where var&quot;#s13&quot;) where B&lt;:ContinuumArrays.Basis,Union{B, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(QuasiArrays.SubQuasiArray{var&quot;#s13&quot;,var&quot;#s17&quot;,var&quot;#s18&quot;,I,L} where L where I where var&quot;#s18&quot;&lt;:B where var&quot;#s17&quot; where var&quot;#s13&quot;) where B&lt;:ContinuumArrays.Basis}, Tuple{Union{B, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(QuasiArrays.SubQuasiArray{var&quot;#s13&quot;,var&quot;#s17&quot;,var&quot;#s18&quot;,I,L} where L where I where var&quot;#s18&quot;&lt;:B where var&quot;#s17&quot; where var&quot;#s13&quot;) where B&lt;:ContinuumArrays.Basis,Union{B, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(QuasiArrays.SubQuasiArray{var&quot;#s13&quot;,var&quot;#s17&quot;,var&quot;#s18&quot;,I,L} where L where I where var&quot;#s18&quot;&lt;:B where var&quot;#s17&quot; where var&quot;#s13&quot;) where B&lt;:ContinuumArrays.Basis,Type{T}}} where T where Conjugated" href="#CompactBases.FunctionProduct-Union{Tuple{T}, Tuple{Conjugated}, Tuple{Union{B, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(QuasiArrays.SubQuasiArray{var&quot;#s13&quot;,var&quot;#s17&quot;,var&quot;#s18&quot;,I,L} where L where I where var&quot;#s18&quot;&lt;:B where var&quot;#s17&quot; where var&quot;#s13&quot;) where B&lt;:ContinuumArrays.Basis,Union{B, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(QuasiArrays.SubQuasiArray{var&quot;#s13&quot;,var&quot;#s17&quot;,var&quot;#s18&quot;,I,L} where L where I where var&quot;#s18&quot;&lt;:B where var&quot;#s17&quot; where var&quot;#s13&quot;) where B&lt;:ContinuumArrays.Basis}, Tuple{Union{B, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(QuasiArrays.SubQuasiArray{var&quot;#s13&quot;,var&quot;#s17&quot;,var&quot;#s18&quot;,I,L} where L where I where var&quot;#s18&quot;&lt;:B where var&quot;#s17&quot; where var&quot;#s13&quot;) where B&lt;:ContinuumArrays.Basis,Union{B, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(QuasiArrays.SubQuasiArray{var&quot;#s13&quot;,var&quot;#s17&quot;,var&quot;#s18&quot;,I,L} where L where I where var&quot;#s18&quot;&lt;:B where var&quot;#s17&quot; where var&quot;#s13&quot;) where B&lt;:ContinuumArrays.Basis,Type{T}}} where T where Conjugated"><code>CompactBases.FunctionProduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FunctionProduct{Conjugated}(L, R[, T; w=one]) where {Conjugated,T}</code></pre><p>Construct a <a href="#CompactBases.FunctionProduct"><code>FunctionProduct</code></a> for computing the product of two functions expanded over <code>L</code> and <code>R</code>, respectively:</p><div>\[h(x) = f^\circ(x)g(x)w(x)\]</div><p>where <span>$w(x)$</span> is an optional weight function, over the basis of <span>$g(x)$</span>, via Vandermonde interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/CompactBases.jl/blob/f18472803177f78645a4f30575071db5aa6cc270/src/densities.jl#LL35-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CompactBases.FunctionProduct-Union{Tuple{Conjugated}, Tuple{Any,Any}} where Conjugated" href="#CompactBases.FunctionProduct-Union{Tuple{Conjugated}, Tuple{Any,Any}} where Conjugated"><code>CompactBases.FunctionProduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FunctionProduct{Conjugated}(f, g) where Conjugated</code></pre><p>Construct a <a href="#CompactBases.FunctionProduct"><code>FunctionProduct</code></a> for computing the product of the two functions <code>f</code> and <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/CompactBases.jl/blob/f18472803177f78645a4f30575071db5aa6cc270/src/densities.jl#LL106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Union{Tuple{Conjugated}, Tuple{FunctionProduct{Conjugated,T,P,A,B,V,M,FT,GT,Tmp} where Tmp where GT where FT where M where V where B where A where P where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}} where Conjugated" href="#Base.copyto!-Union{Tuple{Conjugated}, Tuple{FunctionProduct{Conjugated,T,P,A,B,V,M,FT,GT,Tmp} where Tmp where GT where FT where M where V where B where A where P where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}} where Conjugated"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copyto!(ρ::FunctionProduct{Conjugated}, f::AbstractVector, g::AbstractVector) where Conjugated</code></pre><p>Update the <a href="#CompactBases.FunctionProduct"><code>FunctionProduct</code></a> <code>ρ</code> from the vectors of expansion coefficients, <code>f</code> and <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/CompactBases.jl/blob/f18472803177f78645a4f30575071db5aa6cc270/src/densities.jl#LL150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{FunctionProduct,Any,Any}" href="#Base.copyto!-Tuple{FunctionProduct,Any,Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.copyto!(ρ::FunctionProduct, f, g)</code></pre><p>Update the <a href="#CompactBases.FunctionProduct"><code>FunctionProduct</code></a> <code>ρ</code> from the functions <code>f</code> and <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/CompactBases.jl/blob/f18472803177f78645a4f30575071db5aa6cc270/src/densities.jl#LL187-L191">source</a></section></article><h2 id="Bibliography-1"><a class="docs-heading-anchor" href="#Bibliography-1">Bibliography</a><a class="docs-heading-anchor-permalink" href="#Bibliography-1" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-moerken1991"><a class="tag is-link" href="#citeref-moerken1991">moerken1991</a>K. Mørken (1991). Some Identities for Products and Degree Raising of Splines. Constructive Approximation, 7(1), 195–208. <a href="http://dx.doi.org/10.1007/bf01888153">http://dx.doi.org/10.1007/bf01888153</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../diagonal_operators/">« Diagonal operators</a><a class="docs-footer-nextpage" href="../fd_overview/">Overview »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 17 March 2021 23:45">Wednesday 17 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
